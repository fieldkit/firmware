// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: fk-data.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum FkData_DownloadFlags: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case readingFlagsNone // = 0
  case readingFlagsNotRecording // = 1
  case readingFlagsManual // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .readingFlagsNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .readingFlagsNone
    case 1: self = .readingFlagsNotRecording
    case 2: self = .readingFlagsManual
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .readingFlagsNone: return 0
    case .readingFlagsNotRecording: return 1
    case .readingFlagsManual: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension FkData_DownloadFlags: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [FkData_DownloadFlags] = [
    .readingFlagsNone,
    .readingFlagsNotRecording,
    .readingFlagsManual,
  ]
}

#endif  // swift(>=4.2)

enum FkData_ConditionFlags: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case none // = 0
  case recording // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .recording
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .recording: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension FkData_ConditionFlags: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [FkData_ConditionFlags] = [
    .none,
    .recording,
  ]
}

#endif  // swift(>=4.2)

enum FkData_SignedRecordKind: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case none // = 0
  case modules // = 1
  case schedule // = 2
  case state // = 3
  case rawState // = 4
  case other // = 255
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .modules
    case 2: self = .schedule
    case 3: self = .state
    case 4: self = .rawState
    case 255: self = .other
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .modules: return 1
    case .schedule: return 2
    case .state: return 3
    case .rawState: return 4
    case .other: return 255
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension FkData_SignedRecordKind: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [FkData_SignedRecordKind] = [
    .none,
    .modules,
    .schedule,
    .state,
    .rawState,
    .other,
  ]
}

#endif  // swift(>=4.2)

struct FkData_DeviceLocation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: UInt32 = 0

  var fix: UInt32 = 0

  var time: Int64 = 0

  var longitude: Float = 0

  var latitude: Float = 0

  var altitude: Float = 0

  var coordinates: [Float] = []

  var satellites: UInt32 = 0

  var hdop: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkData_SensorReading {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reading: UInt32 = 0

  var time: Int64 = 0

  var sensor: UInt32 = 0

  var value: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkData_LoggedReading {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: UInt32 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  var location: FkData_DeviceLocation {
    get {return _storage._location ?? FkData_DeviceLocation()}
    set {_uniqueStorage()._location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return _storage._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {_uniqueStorage()._location = nil}

  var reading: FkData_SensorReading {
    get {return _storage._reading ?? FkData_SensorReading()}
    set {_uniqueStorage()._reading = newValue}
  }
  /// Returns true if `reading` has been explicitly set.
  var hasReading: Bool {return _storage._reading != nil}
  /// Clears the value of `reading`. Subsequent reads from it will return its default value.
  mutating func clearReading() {_uniqueStorage()._reading = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct FkData_SensorAndValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sensor: UInt32 = 0

  var value: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkData_ModuleHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var manufacturer: UInt32 = 0

  var kind: UInt32 = 0

  var version: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkData_ModuleInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var position: UInt32 {
    get {return _storage._position}
    set {_uniqueStorage()._position = newValue}
  }

  var address: UInt32 {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var header: FkData_ModuleHeader {
    get {return _storage._header ?? FkData_ModuleHeader()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {_uniqueStorage()._header = nil}

  var firmware: FkData_Firmware {
    get {return _storage._firmware ?? FkData_Firmware()}
    set {_uniqueStorage()._firmware = newValue}
  }
  /// Returns true if `firmware` has been explicitly set.
  var hasFirmware: Bool {return _storage._firmware != nil}
  /// Clears the value of `firmware`. Subsequent reads from it will return its default value.
  mutating func clearFirmware() {_uniqueStorage()._firmware = nil}

  var sensors: [FkData_SensorInfo] {
    get {return _storage._sensors}
    set {_uniqueStorage()._sensors = newValue}
  }

  var id: Data {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var flags: UInt32 {
    get {return _storage._flags}
    set {_uniqueStorage()._flags = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct FkData_SensorInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var number: UInt32 = 0

  var name: String = String()

  var unitOfMeasure: String = String()

  var flags: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkData_Firmware {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var git: String = String()

  var build: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkData_Metadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: Data {
    get {return _storage._deviceID}
    set {_uniqueStorage()._deviceID = newValue}
  }

  var time: Int64 {
    get {return _storage._time}
    set {_uniqueStorage()._time = newValue}
  }

  var git: String {
    get {return _storage._git}
    set {_uniqueStorage()._git = newValue}
  }

  var build: String {
    get {return _storage._build}
    set {_uniqueStorage()._build = newValue}
  }

  var resetCause: UInt32 {
    get {return _storage._resetCause}
    set {_uniqueStorage()._resetCause = newValue}
  }

  var sensors: [FkData_SensorInfo] {
    get {return _storage._sensors}
    set {_uniqueStorage()._sensors = newValue}
  }

  var modules: [FkData_ModuleInfo] {
    get {return _storage._modules}
    set {_uniqueStorage()._modules = newValue}
  }

  var firmware: FkData_Firmware {
    get {return _storage._firmware ?? FkData_Firmware()}
    set {_uniqueStorage()._firmware = newValue}
  }
  /// Returns true if `firmware` has been explicitly set.
  var hasFirmware: Bool {return _storage._firmware != nil}
  /// Clears the value of `firmware`. Subsequent reads from it will return its default value.
  mutating func clearFirmware() {_uniqueStorage()._firmware = nil}

  var generation: Data {
    get {return _storage._generation}
    set {_uniqueStorage()._generation = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct FkData_Status {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var time: Int64 = 0

  var uptime: UInt32 = 0

  var battery: Float = 0

  var memory: UInt32 = 0

  var busy: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkData_LogMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var time: Int64 = 0

  var uptime: UInt32 = 0

  var level: UInt32 = 0

  var facility: String = String()

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkData_SensorGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var module: UInt32 = 0

  var readings: [FkData_SensorAndValue] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkData_Readings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var time: Int64 {
    get {return _storage._time}
    set {_uniqueStorage()._time = newValue}
  }

  var reading: UInt32 {
    get {return _storage._reading}
    set {_uniqueStorage()._reading = newValue}
  }

  var flags: UInt32 {
    get {return _storage._flags}
    set {_uniqueStorage()._flags = newValue}
  }

  var meta: UInt32 {
    get {return _storage._meta}
    set {_uniqueStorage()._meta = newValue}
  }

  var uptime: UInt32 {
    get {return _storage._uptime}
    set {_uniqueStorage()._uptime = newValue}
  }

  var location: FkData_DeviceLocation {
    get {return _storage._location ?? FkData_DeviceLocation()}
    set {_uniqueStorage()._location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return _storage._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {_uniqueStorage()._location = nil}

  var sensorGroups: [FkData_SensorGroup] {
    get {return _storage._sensorGroups}
    set {_uniqueStorage()._sensorGroups = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct FkData_JobSchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cron: Data = SwiftProtobuf.Internal.emptyData

  var interval: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkData_Schedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var readings: FkData_JobSchedule {
    get {return _storage._readings ?? FkData_JobSchedule()}
    set {_uniqueStorage()._readings = newValue}
  }
  /// Returns true if `readings` has been explicitly set.
  var hasReadings: Bool {return _storage._readings != nil}
  /// Clears the value of `readings`. Subsequent reads from it will return its default value.
  mutating func clearReadings() {_uniqueStorage()._readings = nil}

  var network: FkData_JobSchedule {
    get {return _storage._network ?? FkData_JobSchedule()}
    set {_uniqueStorage()._network = newValue}
  }
  /// Returns true if `network` has been explicitly set.
  var hasNetwork: Bool {return _storage._network != nil}
  /// Clears the value of `network`. Subsequent reads from it will return its default value.
  mutating func clearNetwork() {_uniqueStorage()._network = nil}

  var lora: FkData_JobSchedule {
    get {return _storage._lora ?? FkData_JobSchedule()}
    set {_uniqueStorage()._lora = newValue}
  }
  /// Returns true if `lora` has been explicitly set.
  var hasLora: Bool {return _storage._lora != nil}
  /// Clears the value of `lora`. Subsequent reads from it will return its default value.
  mutating func clearLora() {_uniqueStorage()._lora = nil}

  var gps: FkData_JobSchedule {
    get {return _storage._gps ?? FkData_JobSchedule()}
    set {_uniqueStorage()._gps = newValue}
  }
  /// Returns true if `gps` has been explicitly set.
  var hasGps: Bool {return _storage._gps != nil}
  /// Clears the value of `gps`. Subsequent reads from it will return its default value.
  mutating func clearGps() {_uniqueStorage()._gps = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct FkData_Identity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkData_Condition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var flags: UInt32 = 0

  var recording: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkData_NetworkInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ssid: String = String()

  var password: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkData_NetworkSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var networks: [FkData_NetworkInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkData_LoraSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceEui: Data = SwiftProtobuf.Internal.emptyData

  var appKey: Data = SwiftProtobuf.Internal.emptyData

  var appEui: Data = SwiftProtobuf.Internal.emptyData

  var frequencyBand: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// I may break this into a MetaRecord.
struct FkData_DataRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var loggedReading: FkData_LoggedReading {
    get {return _storage._loggedReading ?? FkData_LoggedReading()}
    set {_uniqueStorage()._loggedReading = newValue}
  }
  /// Returns true if `loggedReading` has been explicitly set.
  var hasLoggedReading: Bool {return _storage._loggedReading != nil}
  /// Clears the value of `loggedReading`. Subsequent reads from it will return its default value.
  mutating func clearLoggedReading() {_uniqueStorage()._loggedReading = nil}

  var metadata: FkData_Metadata {
    get {return _storage._metadata ?? FkData_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  var log: FkData_LogMessage {
    get {return _storage._log ?? FkData_LogMessage()}
    set {_uniqueStorage()._log = newValue}
  }
  /// Returns true if `log` has been explicitly set.
  var hasLog: Bool {return _storage._log != nil}
  /// Clears the value of `log`. Subsequent reads from it will return its default value.
  mutating func clearLog() {_uniqueStorage()._log = nil}

  var logs: [FkData_LogMessage] {
    get {return _storage._logs}
    set {_uniqueStorage()._logs = newValue}
  }

  var status: FkData_Status {
    get {return _storage._status ?? FkData_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var readings: FkData_Readings {
    get {return _storage._readings ?? FkData_Readings()}
    set {_uniqueStorage()._readings = newValue}
  }
  /// Returns true if `readings` has been explicitly set.
  var hasReadings: Bool {return _storage._readings != nil}
  /// Clears the value of `readings`. Subsequent reads from it will return its default value.
  mutating func clearReadings() {_uniqueStorage()._readings = nil}

  var modules: [FkData_ModuleInfo] {
    get {return _storage._modules}
    set {_uniqueStorage()._modules = newValue}
  }

  var schedule: FkData_Schedule {
    get {return _storage._schedule ?? FkData_Schedule()}
    set {_uniqueStorage()._schedule = newValue}
  }
  /// Returns true if `schedule` has been explicitly set.
  var hasSchedule: Bool {return _storage._schedule != nil}
  /// Clears the value of `schedule`. Subsequent reads from it will return its default value.
  mutating func clearSchedule() {_uniqueStorage()._schedule = nil}

  var meta: UInt64 {
    get {return _storage._meta}
    set {_uniqueStorage()._meta = newValue}
  }

  var identity: FkData_Identity {
    get {return _storage._identity ?? FkData_Identity()}
    set {_uniqueStorage()._identity = newValue}
  }
  /// Returns true if `identity` has been explicitly set.
  var hasIdentity: Bool {return _storage._identity != nil}
  /// Clears the value of `identity`. Subsequent reads from it will return its default value.
  mutating func clearIdentity() {_uniqueStorage()._identity = nil}

  var condition: FkData_Condition {
    get {return _storage._condition ?? FkData_Condition()}
    set {_uniqueStorage()._condition = newValue}
  }
  /// Returns true if `condition` has been explicitly set.
  var hasCondition: Bool {return _storage._condition != nil}
  /// Clears the value of `condition`. Subsequent reads from it will return its default value.
  mutating func clearCondition() {_uniqueStorage()._condition = nil}

  var lora: FkData_LoraSettings {
    get {return _storage._lora ?? FkData_LoraSettings()}
    set {_uniqueStorage()._lora = newValue}
  }
  /// Returns true if `lora` has been explicitly set.
  var hasLora: Bool {return _storage._lora != nil}
  /// Clears the value of `lora`. Subsequent reads from it will return its default value.
  mutating func clearLora() {_uniqueStorage()._lora = nil}

  var network: FkData_NetworkSettings {
    get {return _storage._network ?? FkData_NetworkSettings()}
    set {_uniqueStorage()._network = newValue}
  }
  /// Returns true if `network` has been explicitly set.
  var hasNetwork: Bool {return _storage._network != nil}
  /// Clears the value of `network`. Subsequent reads from it will return its default value.
  mutating func clearNetwork() {_uniqueStorage()._network = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct FkData_SignedRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: FkData_SignedRecordKind = .none

  var time: Int64 = 0

  var data: Data = SwiftProtobuf.Internal.emptyData

  var hash: Data = SwiftProtobuf.Internal.emptyData

  var record: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkData_LoraRecord {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: Data = SwiftProtobuf.Internal.emptyData

  var time: Int64 = 0

  var number: UInt64 = 0

  var module: UInt32 = 0

  var sensor: UInt64 = 0

  var values: [Float] = []

  var data: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "fk_data"

extension FkData_DownloadFlags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "READING_FLAGS_NONE"),
    1: .same(proto: "READING_FLAGS_NOT_RECORDING"),
    2: .same(proto: "READING_FLAGS_MANUAL"),
  ]
}

extension FkData_ConditionFlags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONDITION_FLAGS_NONE"),
    1: .same(proto: "CONDITION_FLAGS_RECORDING"),
  ]
}

extension FkData_SignedRecordKind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SIGNED_RECORD_KIND_NONE"),
    1: .same(proto: "SIGNED_RECORD_KIND_MODULES"),
    2: .same(proto: "SIGNED_RECORD_KIND_SCHEDULE"),
    3: .same(proto: "SIGNED_RECORD_KIND_STATE"),
    4: .same(proto: "SIGNED_RECORD_KIND_RAW_STATE"),
    255: .same(proto: "SIGNED_RECORD_KIND_OTHER"),
  ]
}

extension FkData_DeviceLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceLocation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    7: .same(proto: "enabled"),
    1: .same(proto: "fix"),
    2: .same(proto: "time"),
    3: .same(proto: "longitude"),
    4: .same(proto: "latitude"),
    5: .same(proto: "altitude"),
    6: .same(proto: "coordinates"),
    8: .same(proto: "satellites"),
    9: .same(proto: "hdop"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.fix)
      case 2: try decoder.decodeSingularInt64Field(value: &self.time)
      case 3: try decoder.decodeSingularFloatField(value: &self.longitude)
      case 4: try decoder.decodeSingularFloatField(value: &self.latitude)
      case 5: try decoder.decodeSingularFloatField(value: &self.altitude)
      case 6: try decoder.decodeRepeatedFloatField(value: &self.coordinates)
      case 7: try decoder.decodeSingularUInt32Field(value: &self.enabled)
      case 8: try decoder.decodeSingularUInt32Field(value: &self.satellites)
      case 9: try decoder.decodeSingularUInt32Field(value: &self.hdop)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fix != 0 {
      try visitor.visitSingularUInt32Field(value: self.fix, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularInt64Field(value: self.time, fieldNumber: 2)
    }
    if self.longitude != 0 {
      try visitor.visitSingularFloatField(value: self.longitude, fieldNumber: 3)
    }
    if self.latitude != 0 {
      try visitor.visitSingularFloatField(value: self.latitude, fieldNumber: 4)
    }
    if self.altitude != 0 {
      try visitor.visitSingularFloatField(value: self.altitude, fieldNumber: 5)
    }
    if !self.coordinates.isEmpty {
      try visitor.visitPackedFloatField(value: self.coordinates, fieldNumber: 6)
    }
    if self.enabled != 0 {
      try visitor.visitSingularUInt32Field(value: self.enabled, fieldNumber: 7)
    }
    if self.satellites != 0 {
      try visitor.visitSingularUInt32Field(value: self.satellites, fieldNumber: 8)
    }
    if self.hdop != 0 {
      try visitor.visitSingularUInt32Field(value: self.hdop, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkData_DeviceLocation, rhs: FkData_DeviceLocation) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.fix != rhs.fix {return false}
    if lhs.time != rhs.time {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.altitude != rhs.altitude {return false}
    if lhs.coordinates != rhs.coordinates {return false}
    if lhs.satellites != rhs.satellites {return false}
    if lhs.hdop != rhs.hdop {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkData_SensorReading: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SensorReading"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reading"),
    2: .same(proto: "time"),
    3: .same(proto: "sensor"),
    4: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.reading)
      case 2: try decoder.decodeSingularInt64Field(value: &self.time)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.sensor)
      case 4: try decoder.decodeSingularFloatField(value: &self.value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reading != 0 {
      try visitor.visitSingularUInt32Field(value: self.reading, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularInt64Field(value: self.time, fieldNumber: 2)
    }
    if self.sensor != 0 {
      try visitor.visitSingularUInt32Field(value: self.sensor, fieldNumber: 3)
    }
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkData_SensorReading, rhs: FkData_SensorReading) -> Bool {
    if lhs.reading != rhs.reading {return false}
    if lhs.time != rhs.time {return false}
    if lhs.sensor != rhs.sensor {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkData_LoggedReading: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoggedReading"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "location"),
    3: .same(proto: "reading"),
  ]

  fileprivate class _StorageClass {
    var _version: UInt32 = 0
    var _location: FkData_DeviceLocation? = nil
    var _reading: FkData_SensorReading? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _version = source._version
      _location = source._location
      _reading = source._reading
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._version)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._location)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._reading)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._version != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._version, fieldNumber: 1)
      }
      if let v = _storage._location {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._reading {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkData_LoggedReading, rhs: FkData_LoggedReading) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._version != rhs_storage._version {return false}
        if _storage._location != rhs_storage._location {return false}
        if _storage._reading != rhs_storage._reading {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkData_SensorAndValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SensorAndValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sensor"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.sensor)
      case 2: try decoder.decodeSingularFloatField(value: &self.value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sensor != 0 {
      try visitor.visitSingularUInt32Field(value: self.sensor, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkData_SensorAndValue, rhs: FkData_SensorAndValue) -> Bool {
    if lhs.sensor != rhs.sensor {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkData_ModuleHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModuleHeader"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "manufacturer"),
    2: .same(proto: "kind"),
    3: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.manufacturer)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.kind)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.version)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.manufacturer != 0 {
      try visitor.visitSingularUInt32Field(value: self.manufacturer, fieldNumber: 1)
    }
    if self.kind != 0 {
      try visitor.visitSingularUInt32Field(value: self.kind, fieldNumber: 2)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkData_ModuleHeader, rhs: FkData_ModuleHeader) -> Bool {
    if lhs.manufacturer != rhs.manufacturer {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkData_ModuleInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModuleInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .same(proto: "address"),
    3: .same(proto: "name"),
    4: .same(proto: "header"),
    5: .same(proto: "firmware"),
    6: .same(proto: "sensors"),
    7: .same(proto: "id"),
    8: .same(proto: "flags"),
  ]

  fileprivate class _StorageClass {
    var _position: UInt32 = 0
    var _address: UInt32 = 0
    var _name: String = String()
    var _header: FkData_ModuleHeader? = nil
    var _firmware: FkData_Firmware? = nil
    var _sensors: [FkData_SensorInfo] = []
    var _id: Data = SwiftProtobuf.Internal.emptyData
    var _flags: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _position = source._position
      _address = source._address
      _name = source._name
      _header = source._header
      _firmware = source._firmware
      _sensors = source._sensors
      _id = source._id
      _flags = source._flags
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._position)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._address)
        case 3: try decoder.decodeSingularStringField(value: &_storage._name)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._header)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._firmware)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._sensors)
        case 7: try decoder.decodeSingularBytesField(value: &_storage._id)
        case 8: try decoder.decodeSingularUInt32Field(value: &_storage._flags)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._position != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._position, fieldNumber: 1)
      }
      if _storage._address != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._address, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._firmware {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._sensors.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sensors, fieldNumber: 6)
      }
      if !_storage._id.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._id, fieldNumber: 7)
      }
      if _storage._flags != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._flags, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkData_ModuleInfo, rhs: FkData_ModuleInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._position != rhs_storage._position {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._header != rhs_storage._header {return false}
        if _storage._firmware != rhs_storage._firmware {return false}
        if _storage._sensors != rhs_storage._sensors {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._flags != rhs_storage._flags {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkData_SensorInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SensorInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "number"),
    2: .same(proto: "name"),
    3: .same(proto: "unitOfMeasure"),
    4: .same(proto: "flags"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.number)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularStringField(value: &self.unitOfMeasure)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.flags)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.number != 0 {
      try visitor.visitSingularUInt32Field(value: self.number, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.unitOfMeasure.isEmpty {
      try visitor.visitSingularStringField(value: self.unitOfMeasure, fieldNumber: 3)
    }
    if self.flags != 0 {
      try visitor.visitSingularUInt32Field(value: self.flags, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkData_SensorInfo, rhs: FkData_SensorInfo) -> Bool {
    if lhs.number != rhs.number {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unitOfMeasure != rhs.unitOfMeasure {return false}
    if lhs.flags != rhs.flags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkData_Firmware: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Firmware"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "git"),
    2: .same(proto: "build"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.git)
      case 2: try decoder.decodeSingularStringField(value: &self.build)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.git.isEmpty {
      try visitor.visitSingularStringField(value: self.git, fieldNumber: 1)
    }
    if !self.build.isEmpty {
      try visitor.visitSingularStringField(value: self.build, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkData_Firmware, rhs: FkData_Firmware) -> Bool {
    if lhs.git != rhs.git {return false}
    if lhs.build != rhs.build {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkData_Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Metadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
    2: .same(proto: "time"),
    3: .same(proto: "git"),
    7: .same(proto: "build"),
    4: .same(proto: "resetCause"),
    5: .same(proto: "sensors"),
    6: .same(proto: "modules"),
    8: .same(proto: "firmware"),
    9: .same(proto: "generation"),
  ]

  fileprivate class _StorageClass {
    var _deviceID: Data = SwiftProtobuf.Internal.emptyData
    var _time: Int64 = 0
    var _git: String = String()
    var _build: String = String()
    var _resetCause: UInt32 = 0
    var _sensors: [FkData_SensorInfo] = []
    var _modules: [FkData_ModuleInfo] = []
    var _firmware: FkData_Firmware? = nil
    var _generation: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _deviceID = source._deviceID
      _time = source._time
      _git = source._git
      _build = source._build
      _resetCause = source._resetCause
      _sensors = source._sensors
      _modules = source._modules
      _firmware = source._firmware
      _generation = source._generation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._deviceID)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._time)
        case 3: try decoder.decodeSingularStringField(value: &_storage._git)
        case 4: try decoder.decodeSingularUInt32Field(value: &_storage._resetCause)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._sensors)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._modules)
        case 7: try decoder.decodeSingularStringField(value: &_storage._build)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._firmware)
        case 9: try decoder.decodeSingularBytesField(value: &_storage._generation)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._deviceID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._deviceID, fieldNumber: 1)
      }
      if _storage._time != 0 {
        try visitor.visitSingularInt64Field(value: _storage._time, fieldNumber: 2)
      }
      if !_storage._git.isEmpty {
        try visitor.visitSingularStringField(value: _storage._git, fieldNumber: 3)
      }
      if _storage._resetCause != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._resetCause, fieldNumber: 4)
      }
      if !_storage._sensors.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sensors, fieldNumber: 5)
      }
      if !_storage._modules.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._modules, fieldNumber: 6)
      }
      if !_storage._build.isEmpty {
        try visitor.visitSingularStringField(value: _storage._build, fieldNumber: 7)
      }
      if let v = _storage._firmware {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if !_storage._generation.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._generation, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkData_Metadata, rhs: FkData_Metadata) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._deviceID != rhs_storage._deviceID {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._git != rhs_storage._git {return false}
        if _storage._build != rhs_storage._build {return false}
        if _storage._resetCause != rhs_storage._resetCause {return false}
        if _storage._sensors != rhs_storage._sensors {return false}
        if _storage._modules != rhs_storage._modules {return false}
        if _storage._firmware != rhs_storage._firmware {return false}
        if _storage._generation != rhs_storage._generation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkData_Status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Status"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "uptime"),
    3: .same(proto: "battery"),
    4: .same(proto: "memory"),
    5: .same(proto: "busy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.time)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.uptime)
      case 3: try decoder.decodeSingularFloatField(value: &self.battery)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.memory)
      case 5: try decoder.decodeSingularUInt64Field(value: &self.busy)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.time != 0 {
      try visitor.visitSingularInt64Field(value: self.time, fieldNumber: 1)
    }
    if self.uptime != 0 {
      try visitor.visitSingularUInt32Field(value: self.uptime, fieldNumber: 2)
    }
    if self.battery != 0 {
      try visitor.visitSingularFloatField(value: self.battery, fieldNumber: 3)
    }
    if self.memory != 0 {
      try visitor.visitSingularUInt32Field(value: self.memory, fieldNumber: 4)
    }
    if self.busy != 0 {
      try visitor.visitSingularUInt64Field(value: self.busy, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkData_Status, rhs: FkData_Status) -> Bool {
    if lhs.time != rhs.time {return false}
    if lhs.uptime != rhs.uptime {return false}
    if lhs.battery != rhs.battery {return false}
    if lhs.memory != rhs.memory {return false}
    if lhs.busy != rhs.busy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkData_LogMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LogMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "uptime"),
    3: .same(proto: "level"),
    4: .same(proto: "facility"),
    5: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.time)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.uptime)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.level)
      case 4: try decoder.decodeSingularStringField(value: &self.facility)
      case 5: try decoder.decodeSingularStringField(value: &self.message)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.time != 0 {
      try visitor.visitSingularInt64Field(value: self.time, fieldNumber: 1)
    }
    if self.uptime != 0 {
      try visitor.visitSingularUInt32Field(value: self.uptime, fieldNumber: 2)
    }
    if self.level != 0 {
      try visitor.visitSingularUInt32Field(value: self.level, fieldNumber: 3)
    }
    if !self.facility.isEmpty {
      try visitor.visitSingularStringField(value: self.facility, fieldNumber: 4)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkData_LogMessage, rhs: FkData_LogMessage) -> Bool {
    if lhs.time != rhs.time {return false}
    if lhs.uptime != rhs.uptime {return false}
    if lhs.level != rhs.level {return false}
    if lhs.facility != rhs.facility {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkData_SensorGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SensorGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "module"),
    2: .same(proto: "readings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.module)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.readings)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.module != 0 {
      try visitor.visitSingularUInt32Field(value: self.module, fieldNumber: 1)
    }
    if !self.readings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.readings, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkData_SensorGroup, rhs: FkData_SensorGroup) -> Bool {
    if lhs.module != rhs.module {return false}
    if lhs.readings != rhs.readings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkData_Readings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Readings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "reading"),
    3: .same(proto: "flags"),
    6: .same(proto: "meta"),
    7: .same(proto: "uptime"),
    4: .same(proto: "location"),
    5: .same(proto: "sensorGroups"),
  ]

  fileprivate class _StorageClass {
    var _time: Int64 = 0
    var _reading: UInt32 = 0
    var _flags: UInt32 = 0
    var _meta: UInt32 = 0
    var _uptime: UInt32 = 0
    var _location: FkData_DeviceLocation? = nil
    var _sensorGroups: [FkData_SensorGroup] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _time = source._time
      _reading = source._reading
      _flags = source._flags
      _meta = source._meta
      _uptime = source._uptime
      _location = source._location
      _sensorGroups = source._sensorGroups
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt64Field(value: &_storage._time)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._reading)
        case 3: try decoder.decodeSingularUInt32Field(value: &_storage._flags)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._location)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._sensorGroups)
        case 6: try decoder.decodeSingularUInt32Field(value: &_storage._meta)
        case 7: try decoder.decodeSingularUInt32Field(value: &_storage._uptime)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._time != 0 {
        try visitor.visitSingularInt64Field(value: _storage._time, fieldNumber: 1)
      }
      if _storage._reading != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._reading, fieldNumber: 2)
      }
      if _storage._flags != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._flags, fieldNumber: 3)
      }
      if let v = _storage._location {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._sensorGroups.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sensorGroups, fieldNumber: 5)
      }
      if _storage._meta != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._meta, fieldNumber: 6)
      }
      if _storage._uptime != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._uptime, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkData_Readings, rhs: FkData_Readings) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._time != rhs_storage._time {return false}
        if _storage._reading != rhs_storage._reading {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._meta != rhs_storage._meta {return false}
        if _storage._uptime != rhs_storage._uptime {return false}
        if _storage._location != rhs_storage._location {return false}
        if _storage._sensorGroups != rhs_storage._sensorGroups {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkData_JobSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".JobSchedule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cron"),
    2: .same(proto: "interval"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.cron)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.interval)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cron.isEmpty {
      try visitor.visitSingularBytesField(value: self.cron, fieldNumber: 1)
    }
    if self.interval != 0 {
      try visitor.visitSingularUInt32Field(value: self.interval, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkData_JobSchedule, rhs: FkData_JobSchedule) -> Bool {
    if lhs.cron != rhs.cron {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkData_Schedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Schedule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "readings"),
    2: .same(proto: "network"),
    3: .same(proto: "lora"),
    4: .same(proto: "gps"),
  ]

  fileprivate class _StorageClass {
    var _readings: FkData_JobSchedule? = nil
    var _network: FkData_JobSchedule? = nil
    var _lora: FkData_JobSchedule? = nil
    var _gps: FkData_JobSchedule? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _readings = source._readings
      _network = source._network
      _lora = source._lora
      _gps = source._gps
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._readings)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._network)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._lora)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._gps)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._readings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._network {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._lora {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._gps {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkData_Schedule, rhs: FkData_Schedule) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._readings != rhs_storage._readings {return false}
        if _storage._network != rhs_storage._network {return false}
        if _storage._lora != rhs_storage._lora {return false}
        if _storage._gps != rhs_storage._gps {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkData_Identity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Identity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkData_Identity, rhs: FkData_Identity) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkData_Condition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Condition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "flags"),
    2: .same(proto: "recording"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.flags)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.recording)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.flags != 0 {
      try visitor.visitSingularUInt32Field(value: self.flags, fieldNumber: 1)
    }
    if self.recording != 0 {
      try visitor.visitSingularUInt32Field(value: self.recording, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkData_Condition, rhs: FkData_Condition) -> Bool {
    if lhs.flags != rhs.flags {return false}
    if lhs.recording != rhs.recording {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkData_NetworkInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ssid"),
    2: .same(proto: "password"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.ssid)
      case 2: try decoder.decodeSingularStringField(value: &self.password)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ssid.isEmpty {
      try visitor.visitSingularStringField(value: self.ssid, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkData_NetworkInfo, rhs: FkData_NetworkInfo) -> Bool {
    if lhs.ssid != rhs.ssid {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkData_NetworkSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "networks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.networks)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.networks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.networks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkData_NetworkSettings, rhs: FkData_NetworkSettings) -> Bool {
    if lhs.networks != rhs.networks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkData_LoraSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoraSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceEui"),
    2: .same(proto: "appKey"),
    3: .same(proto: "appEui"),
    4: .same(proto: "frequencyBand"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.deviceEui)
      case 2: try decoder.decodeSingularBytesField(value: &self.appKey)
      case 3: try decoder.decodeSingularBytesField(value: &self.appEui)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.frequencyBand)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceEui.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceEui, fieldNumber: 1)
    }
    if !self.appKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.appKey, fieldNumber: 2)
    }
    if !self.appEui.isEmpty {
      try visitor.visitSingularBytesField(value: self.appEui, fieldNumber: 3)
    }
    if self.frequencyBand != 0 {
      try visitor.visitSingularUInt32Field(value: self.frequencyBand, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkData_LoraSettings, rhs: FkData_LoraSettings) -> Bool {
    if lhs.deviceEui != rhs.deviceEui {return false}
    if lhs.appKey != rhs.appKey {return false}
    if lhs.appEui != rhs.appEui {return false}
    if lhs.frequencyBand != rhs.frequencyBand {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkData_DataRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DataRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "loggedReading"),
    2: .same(proto: "metadata"),
    3: .same(proto: "log"),
    13: .same(proto: "logs"),
    4: .same(proto: "status"),
    5: .same(proto: "readings"),
    6: .same(proto: "modules"),
    7: .same(proto: "schedule"),
    8: .same(proto: "meta"),
    9: .same(proto: "identity"),
    10: .same(proto: "condition"),
    11: .same(proto: "lora"),
    12: .same(proto: "network"),
  ]

  fileprivate class _StorageClass {
    var _loggedReading: FkData_LoggedReading? = nil
    var _metadata: FkData_Metadata? = nil
    var _log: FkData_LogMessage? = nil
    var _logs: [FkData_LogMessage] = []
    var _status: FkData_Status? = nil
    var _readings: FkData_Readings? = nil
    var _modules: [FkData_ModuleInfo] = []
    var _schedule: FkData_Schedule? = nil
    var _meta: UInt64 = 0
    var _identity: FkData_Identity? = nil
    var _condition: FkData_Condition? = nil
    var _lora: FkData_LoraSettings? = nil
    var _network: FkData_NetworkSettings? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _loggedReading = source._loggedReading
      _metadata = source._metadata
      _log = source._log
      _logs = source._logs
      _status = source._status
      _readings = source._readings
      _modules = source._modules
      _schedule = source._schedule
      _meta = source._meta
      _identity = source._identity
      _condition = source._condition
      _lora = source._lora
      _network = source._network
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._loggedReading)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._log)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._status)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._readings)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._modules)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._schedule)
        case 8: try decoder.decodeSingularUInt64Field(value: &_storage._meta)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._identity)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._condition)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._lora)
        case 12: try decoder.decodeSingularMessageField(value: &_storage._network)
        case 13: try decoder.decodeRepeatedMessageField(value: &_storage._logs)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._loggedReading {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._log {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._readings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._modules.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._modules, fieldNumber: 6)
      }
      if let v = _storage._schedule {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if _storage._meta != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._meta, fieldNumber: 8)
      }
      if let v = _storage._identity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._condition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._lora {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._network {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if !_storage._logs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._logs, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkData_DataRecord, rhs: FkData_DataRecord) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._loggedReading != rhs_storage._loggedReading {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._log != rhs_storage._log {return false}
        if _storage._logs != rhs_storage._logs {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._readings != rhs_storage._readings {return false}
        if _storage._modules != rhs_storage._modules {return false}
        if _storage._schedule != rhs_storage._schedule {return false}
        if _storage._meta != rhs_storage._meta {return false}
        if _storage._identity != rhs_storage._identity {return false}
        if _storage._condition != rhs_storage._condition {return false}
        if _storage._lora != rhs_storage._lora {return false}
        if _storage._network != rhs_storage._network {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkData_SignedRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignedRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "time"),
    3: .same(proto: "data"),
    4: .same(proto: "hash"),
    5: .same(proto: "record"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.kind)
      case 2: try decoder.decodeSingularInt64Field(value: &self.time)
      case 3: try decoder.decodeSingularBytesField(value: &self.data)
      case 4: try decoder.decodeSingularBytesField(value: &self.hash)
      case 5: try decoder.decodeSingularUInt64Field(value: &self.record)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .none {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularInt64Field(value: self.time, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 4)
    }
    if self.record != 0 {
      try visitor.visitSingularUInt64Field(value: self.record, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkData_SignedRecord, rhs: FkData_SignedRecord) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.time != rhs.time {return false}
    if lhs.data != rhs.data {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.record != rhs.record {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkData_LoraRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoraRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deviceId"),
    2: .same(proto: "time"),
    3: .same(proto: "number"),
    4: .same(proto: "module"),
    5: .same(proto: "sensor"),
    6: .same(proto: "values"),
    7: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.deviceID)
      case 2: try decoder.decodeSingularInt64Field(value: &self.time)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.number)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.module)
      case 5: try decoder.decodeSingularUInt64Field(value: &self.sensor)
      case 6: try decoder.decodeRepeatedFloatField(value: &self.values)
      case 7: try decoder.decodeSingularBytesField(value: &self.data)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceID, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularInt64Field(value: self.time, fieldNumber: 2)
    }
    if self.number != 0 {
      try visitor.visitSingularUInt64Field(value: self.number, fieldNumber: 3)
    }
    if self.module != 0 {
      try visitor.visitSingularUInt32Field(value: self.module, fieldNumber: 4)
    }
    if self.sensor != 0 {
      try visitor.visitSingularUInt64Field(value: self.sensor, fieldNumber: 5)
    }
    if !self.values.isEmpty {
      try visitor.visitPackedFloatField(value: self.values, fieldNumber: 6)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkData_LoraRecord, rhs: FkData_LoraRecord) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.time != rhs.time {return false}
    if lhs.number != rhs.number {return false}
    if lhs.module != rhs.module {return false}
    if lhs.sensor != rhs.sensor {return false}
    if lhs.values != rhs.values {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
