// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: fk-app.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum FkApp_QueryType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case queryNone // = 0
  case queryCapabilities // = 1
  case queryConfigureSensor // = 2
  case queryLiveDataPoll // = 7
  case querySchedules // = 8
  case queryConfigueSchedules // = 9
  case queryFiles // = 10
  case queryDownloadFile // = 11
  case queryEraseFile // = 12
  case queryReset // = 13
  case queryNetworkSettings // = 14
  case queryConfigureNetworkSettings // = 15
  case queryIdentity // = 16
  case queryConfigureIdentity // = 17
  case queryStatus // = 18
  case queryModule // = 19
  case queryMetadata // = 20
  case queryFormat // = 21
  case queryGetReadings // = 22
  case queryTakeReadings // = 23
  case queryRecordingControl // = 24
  case queryConfigure // = 25
  case UNRECOGNIZED(Int)

  init() {
    self = .queryNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .queryNone
    case 1: self = .queryCapabilities
    case 2: self = .queryConfigureSensor
    case 7: self = .queryLiveDataPoll
    case 8: self = .querySchedules
    case 9: self = .queryConfigueSchedules
    case 10: self = .queryFiles
    case 11: self = .queryDownloadFile
    case 12: self = .queryEraseFile
    case 13: self = .queryReset
    case 14: self = .queryNetworkSettings
    case 15: self = .queryConfigureNetworkSettings
    case 16: self = .queryIdentity
    case 17: self = .queryConfigureIdentity
    case 18: self = .queryStatus
    case 19: self = .queryModule
    case 20: self = .queryMetadata
    case 21: self = .queryFormat
    case 22: self = .queryGetReadings
    case 23: self = .queryTakeReadings
    case 24: self = .queryRecordingControl
    case 25: self = .queryConfigure
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .queryNone: return 0
    case .queryCapabilities: return 1
    case .queryConfigureSensor: return 2
    case .queryLiveDataPoll: return 7
    case .querySchedules: return 8
    case .queryConfigueSchedules: return 9
    case .queryFiles: return 10
    case .queryDownloadFile: return 11
    case .queryEraseFile: return 12
    case .queryReset: return 13
    case .queryNetworkSettings: return 14
    case .queryConfigureNetworkSettings: return 15
    case .queryIdentity: return 16
    case .queryConfigureIdentity: return 17
    case .queryStatus: return 18
    case .queryModule: return 19
    case .queryMetadata: return 20
    case .queryFormat: return 21
    case .queryGetReadings: return 22
    case .queryTakeReadings: return 23
    case .queryRecordingControl: return 24
    case .queryConfigure: return 25
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension FkApp_QueryType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [FkApp_QueryType] = [
    .queryNone,
    .queryCapabilities,
    .queryConfigureSensor,
    .queryLiveDataPoll,
    .querySchedules,
    .queryConfigueSchedules,
    .queryFiles,
    .queryDownloadFile,
    .queryEraseFile,
    .queryReset,
    .queryNetworkSettings,
    .queryConfigureNetworkSettings,
    .queryIdentity,
    .queryConfigureIdentity,
    .queryStatus,
    .queryModule,
    .queryMetadata,
    .queryFormat,
    .queryGetReadings,
    .queryTakeReadings,
    .queryRecordingControl,
    .queryConfigure,
  ]
}

#endif  // swift(>=4.2)

enum FkApp_ReplyType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case replyNone // = 0
  case replySuccess // = 1
  case replyBusy // = 2
  case replyError // = 3
  case replyCapabilities // = 4
  case replyLiveDataPoll // = 8
  case replySchedules // = 9
  case replyFiles // = 10
  case replyDownloadFile // = 11
  case replyReset // = 12
  case replyNetworkSettings // = 13
  case replyIdentity // = 14
  case replyStatus // = 15
  case replyModule // = 16
  case replyMetadata // = 17
  case replyReadings // = 18
  case UNRECOGNIZED(Int)

  init() {
    self = .replyNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .replyNone
    case 1: self = .replySuccess
    case 2: self = .replyBusy
    case 3: self = .replyError
    case 4: self = .replyCapabilities
    case 8: self = .replyLiveDataPoll
    case 9: self = .replySchedules
    case 10: self = .replyFiles
    case 11: self = .replyDownloadFile
    case 12: self = .replyReset
    case 13: self = .replyNetworkSettings
    case 14: self = .replyIdentity
    case 15: self = .replyStatus
    case 16: self = .replyModule
    case 17: self = .replyMetadata
    case 18: self = .replyReadings
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .replyNone: return 0
    case .replySuccess: return 1
    case .replyBusy: return 2
    case .replyError: return 3
    case .replyCapabilities: return 4
    case .replyLiveDataPoll: return 8
    case .replySchedules: return 9
    case .replyFiles: return 10
    case .replyDownloadFile: return 11
    case .replyReset: return 12
    case .replyNetworkSettings: return 13
    case .replyIdentity: return 14
    case .replyStatus: return 15
    case .replyModule: return 16
    case .replyMetadata: return 17
    case .replyReadings: return 18
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension FkApp_ReplyType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [FkApp_ReplyType] = [
    .replyNone,
    .replySuccess,
    .replyBusy,
    .replyError,
    .replyCapabilities,
    .replyLiveDataPoll,
    .replySchedules,
    .replyFiles,
    .replyDownloadFile,
    .replyReset,
    .replyNetworkSettings,
    .replyIdentity,
    .replyStatus,
    .replyModule,
    .replyMetadata,
    .replyReadings,
  ]
}

#endif  // swift(>=4.2)

enum FkApp_DownloadFlags: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case downloadFlagNone // = 0
  case downloadFlagMetadataPrepend // = 1
  case downloadFlagMetadataOnly // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .downloadFlagNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .downloadFlagNone
    case 1: self = .downloadFlagMetadataPrepend
    case 2: self = .downloadFlagMetadataOnly
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .downloadFlagNone: return 0
    case .downloadFlagMetadataPrepend: return 1
    case .downloadFlagMetadataOnly: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension FkApp_DownloadFlags: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [FkApp_DownloadFlags] = [
    .downloadFlagNone,
    .downloadFlagMetadataPrepend,
    .downloadFlagMetadataOnly,
  ]
}

#endif  // swift(>=4.2)

enum FkApp_ModuleFlags: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case moduleFlagNone // = 0
  case moduleFlagInternal // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .moduleFlagNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .moduleFlagNone
    case 1: self = .moduleFlagInternal
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .moduleFlagNone: return 0
    case .moduleFlagInternal: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension FkApp_ModuleFlags: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [FkApp_ModuleFlags] = [
    .moduleFlagNone,
    .moduleFlagInternal,
  ]
}

#endif  // swift(>=4.2)

enum FkApp_SensorFlags: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case sensorFlagNone // = 0
  case UNRECOGNIZED(Int)

  init() {
    self = .sensorFlagNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sensorFlagNone
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .sensorFlagNone: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension FkApp_SensorFlags: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [FkApp_SensorFlags] = [
    .sensorFlagNone,
  ]
}

#endif  // swift(>=4.2)

struct FkApp_QueryCapabilities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: UInt32 = 0

  var callerTime: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_LiveValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var valid: Bool = false

  var value: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_SensorCapabilities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var number: UInt32 {
    get {return _storage._number}
    set {_uniqueStorage()._number = newValue}
  }

  var module: UInt32 {
    get {return _storage._module}
    set {_uniqueStorage()._module = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var frequency: UInt32 {
    get {return _storage._frequency}
    set {_uniqueStorage()._frequency = newValue}
  }

  var unitOfMeasure: String {
    get {return _storage._unitOfMeasure}
    set {_uniqueStorage()._unitOfMeasure = newValue}
  }

  /// v2
  var path: String {
    get {return _storage._path}
    set {_uniqueStorage()._path = newValue}
  }

  var flags: UInt32 {
    get {return _storage._flags}
    set {_uniqueStorage()._flags = newValue}
  }

  var value: FkApp_LiveValue {
    get {return _storage._value ?? FkApp_LiveValue()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {_uniqueStorage()._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct FkApp_ModuleCapabilities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var position: UInt32 = 0

  var name: String = String()

  var sensors: [FkApp_SensorCapabilities] = []

  /// v2
  var path: String = String()

  var flags: UInt32 = 0

  var id: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_Capabilities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: UInt32 = 0

  var deviceID: Data = SwiftProtobuf.Internal.emptyData

  var name: String = String()

  var modules: [FkApp_ModuleCapabilities] = []

  var sensors: [FkApp_SensorCapabilities] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_NetworkInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ssid: String = String()

  var password: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_NetworkSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var createAccessPoint: Int32 = 0

  var networks: [FkApp_NetworkInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_Firmware {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var git: String = String()

  var build: String = String()

  var number: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_Identity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var device: String = String()

  var stream: String = String()

  var deviceID: Data = SwiftProtobuf.Internal.emptyData

  var firmware: String = String()

  var build: String = String()

  var number: String = String()

  /// v2
  var name: String = String()

  var generation: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_ConfigureSensorQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt32 = 0

  var frequency: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_LiveDataPoll {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var interval: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_LiveDataSample {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sensor: UInt32 = 0

  var time: UInt64 = 0

  var value: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_LiveData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var samples: [FkApp_LiveDataSample] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_File {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt32 = 0

  var time: UInt64 = 0

  var size: UInt64 = 0

  var version: UInt32 = 0

  var name: String = String()

  var maximum: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_Files {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var files: [FkApp_File] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_DownloadFile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt32 = 0

  var offset: UInt32 = 0

  var length: UInt32 = 0

  var flags: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_EraseFile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_FileData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var offset: UInt32 = 0

  var data: Data = SwiftProtobuf.Internal.emptyData

  var size: UInt32 = 0

  var hash: UInt32 = 0

  var version: UInt32 = 0

  var id: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_DeviceStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uptime: UInt32 = 0

  var batteryPercentage: Float = 0

  var batteryVoltage: Float = 0

  var gpsHasFix: UInt32 = 0

  var gpsSatellites: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_QueryModule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt32 = 0

  var address: UInt32 = 0

  var message: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_ModuleReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt32 = 0

  var address: UInt32 = 0

  var message: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_WireMessageQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: FkApp_QueryType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var queryCapabilities: FkApp_QueryCapabilities {
    get {return _storage._queryCapabilities ?? FkApp_QueryCapabilities()}
    set {_uniqueStorage()._queryCapabilities = newValue}
  }
  /// Returns true if `queryCapabilities` has been explicitly set.
  var hasQueryCapabilities: Bool {return _storage._queryCapabilities != nil}
  /// Clears the value of `queryCapabilities`. Subsequent reads from it will return its default value.
  mutating func clearQueryCapabilities() {_uniqueStorage()._queryCapabilities = nil}

  var configureSensor: FkApp_ConfigureSensorQuery {
    get {return _storage._configureSensor ?? FkApp_ConfigureSensorQuery()}
    set {_uniqueStorage()._configureSensor = newValue}
  }
  /// Returns true if `configureSensor` has been explicitly set.
  var hasConfigureSensor: Bool {return _storage._configureSensor != nil}
  /// Clears the value of `configureSensor`. Subsequent reads from it will return its default value.
  mutating func clearConfigureSensor() {_uniqueStorage()._configureSensor = nil}

  var liveDataPoll: FkApp_LiveDataPoll {
    get {return _storage._liveDataPoll ?? FkApp_LiveDataPoll()}
    set {_uniqueStorage()._liveDataPoll = newValue}
  }
  /// Returns true if `liveDataPoll` has been explicitly set.
  var hasLiveDataPoll: Bool {return _storage._liveDataPoll != nil}
  /// Clears the value of `liveDataPoll`. Subsequent reads from it will return its default value.
  mutating func clearLiveDataPoll() {_uniqueStorage()._liveDataPoll = nil}

  /// Schedules newSchedules = 9;
  var downloadFile: FkApp_DownloadFile {
    get {return _storage._downloadFile ?? FkApp_DownloadFile()}
    set {_uniqueStorage()._downloadFile = newValue}
  }
  /// Returns true if `downloadFile` has been explicitly set.
  var hasDownloadFile: Bool {return _storage._downloadFile != nil}
  /// Clears the value of `downloadFile`. Subsequent reads from it will return its default value.
  mutating func clearDownloadFile() {_uniqueStorage()._downloadFile = nil}

  var eraseFile: FkApp_EraseFile {
    get {return _storage._eraseFile ?? FkApp_EraseFile()}
    set {_uniqueStorage()._eraseFile = newValue}
  }
  /// Returns true if `eraseFile` has been explicitly set.
  var hasEraseFile: Bool {return _storage._eraseFile != nil}
  /// Clears the value of `eraseFile`. Subsequent reads from it will return its default value.
  mutating func clearEraseFile() {_uniqueStorage()._eraseFile = nil}

  var networkSettings: FkApp_NetworkSettings {
    get {return _storage._networkSettings ?? FkApp_NetworkSettings()}
    set {_uniqueStorage()._networkSettings = newValue}
  }
  /// Returns true if `networkSettings` has been explicitly set.
  var hasNetworkSettings: Bool {return _storage._networkSettings != nil}
  /// Clears the value of `networkSettings`. Subsequent reads from it will return its default value.
  mutating func clearNetworkSettings() {_uniqueStorage()._networkSettings = nil}

  var identity: FkApp_Identity {
    get {return _storage._identity ?? FkApp_Identity()}
    set {_uniqueStorage()._identity = newValue}
  }
  /// Returns true if `identity` has been explicitly set.
  var hasIdentity: Bool {return _storage._identity != nil}
  /// Clears the value of `identity`. Subsequent reads from it will return its default value.
  mutating func clearIdentity() {_uniqueStorage()._identity = nil}

  var module: FkApp_QueryModule {
    get {return _storage._module ?? FkApp_QueryModule()}
    set {_uniqueStorage()._module = newValue}
  }
  /// Returns true if `module` has been explicitly set.
  var hasModule: Bool {return _storage._module != nil}
  /// Clears the value of `module`. Subsequent reads from it will return its default value.
  mutating func clearModule() {_uniqueStorage()._module = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct FkApp_Error {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var delay: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_WireMessageReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: FkApp_ReplyType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var errors: [FkApp_Error] {
    get {return _storage._errors}
    set {_uniqueStorage()._errors = newValue}
  }

  var capabilities: FkApp_Capabilities {
    get {return _storage._capabilities ?? FkApp_Capabilities()}
    set {_uniqueStorage()._capabilities = newValue}
  }
  /// Returns true if `capabilities` has been explicitly set.
  var hasCapabilities: Bool {return _storage._capabilities != nil}
  /// Clears the value of `capabilities`. Subsequent reads from it will return its default value.
  mutating func clearCapabilities() {_uniqueStorage()._capabilities = nil}

  var liveData: FkApp_LiveData {
    get {return _storage._liveData ?? FkApp_LiveData()}
    set {_uniqueStorage()._liveData = newValue}
  }
  /// Returns true if `liveData` has been explicitly set.
  var hasLiveData: Bool {return _storage._liveData != nil}
  /// Clears the value of `liveData`. Subsequent reads from it will return its default value.
  mutating func clearLiveData() {_uniqueStorage()._liveData = nil}

  /// Schedules schedules = 7;
  var files: FkApp_Files {
    get {return _storage._files ?? FkApp_Files()}
    set {_uniqueStorage()._files = newValue}
  }
  /// Returns true if `files` has been explicitly set.
  var hasFiles: Bool {return _storage._files != nil}
  /// Clears the value of `files`. Subsequent reads from it will return its default value.
  mutating func clearFiles() {_uniqueStorage()._files = nil}

  var fileData: FkApp_FileData {
    get {return _storage._fileData ?? FkApp_FileData()}
    set {_uniqueStorage()._fileData = newValue}
  }
  /// Returns true if `fileData` has been explicitly set.
  var hasFileData: Bool {return _storage._fileData != nil}
  /// Clears the value of `fileData`. Subsequent reads from it will return its default value.
  mutating func clearFileData() {_uniqueStorage()._fileData = nil}

  var networkSettings: FkApp_NetworkSettings {
    get {return _storage._networkSettings ?? FkApp_NetworkSettings()}
    set {_uniqueStorage()._networkSettings = newValue}
  }
  /// Returns true if `networkSettings` has been explicitly set.
  var hasNetworkSettings: Bool {return _storage._networkSettings != nil}
  /// Clears the value of `networkSettings`. Subsequent reads from it will return its default value.
  mutating func clearNetworkSettings() {_uniqueStorage()._networkSettings = nil}

  var identity: FkApp_Identity {
    get {return _storage._identity ?? FkApp_Identity()}
    set {_uniqueStorage()._identity = newValue}
  }
  /// Returns true if `identity` has been explicitly set.
  var hasIdentity: Bool {return _storage._identity != nil}
  /// Clears the value of `identity`. Subsequent reads from it will return its default value.
  mutating func clearIdentity() {_uniqueStorage()._identity = nil}

  var status: FkApp_DeviceStatus {
    get {return _storage._status ?? FkApp_DeviceStatus()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var module: FkApp_ModuleReply {
    get {return _storage._module ?? FkApp_ModuleReply()}
    set {_uniqueStorage()._module = newValue}
  }
  /// Returns true if `module` has been explicitly set.
  var hasModule: Bool {return _storage._module != nil}
  /// Clears the value of `module`. Subsequent reads from it will return its default value.
  mutating func clearModule() {_uniqueStorage()._module = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct FkApp_Schedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cron: Data = SwiftProtobuf.Internal.emptyData

  var interval: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_Schedules {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var modifying: Bool {
    get {return _storage._modifying}
    set {_uniqueStorage()._modifying = newValue}
  }

  var readings: FkApp_Schedule {
    get {return _storage._readings ?? FkApp_Schedule()}
    set {_uniqueStorage()._readings = newValue}
  }
  /// Returns true if `readings` has been explicitly set.
  var hasReadings: Bool {return _storage._readings != nil}
  /// Clears the value of `readings`. Subsequent reads from it will return its default value.
  mutating func clearReadings() {_uniqueStorage()._readings = nil}

  var lora: FkApp_Schedule {
    get {return _storage._lora ?? FkApp_Schedule()}
    set {_uniqueStorage()._lora = newValue}
  }
  /// Returns true if `lora` has been explicitly set.
  var hasLora: Bool {return _storage._lora != nil}
  /// Clears the value of `lora`. Subsequent reads from it will return its default value.
  mutating func clearLora() {_uniqueStorage()._lora = nil}

  var network: FkApp_Schedule {
    get {return _storage._network ?? FkApp_Schedule()}
    set {_uniqueStorage()._network = newValue}
  }
  /// Returns true if `network` has been explicitly set.
  var hasNetwork: Bool {return _storage._network != nil}
  /// Clears the value of `network`. Subsequent reads from it will return its default value.
  mutating func clearNetwork() {_uniqueStorage()._network = nil}

  var gps: FkApp_Schedule {
    get {return _storage._gps ?? FkApp_Schedule()}
    set {_uniqueStorage()._gps = newValue}
  }
  /// Returns true if `gps` has been explicitly set.
  var hasGps: Bool {return _storage._gps != nil}
  /// Clears the value of `gps`. Subsequent reads from it will return its default value.
  mutating func clearGps() {_uniqueStorage()._gps = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct FkApp_HardwareStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_GpsStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: UInt32 = 0

  var fix: UInt32 = 0

  var time: UInt64 = 0

  var satellites: UInt32 = 0

  var longitude: Float = 0

  var latitude: Float = 0

  var altitude: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_MemoryStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sramAvailable: UInt32 = 0

  var programFlashAvailable: UInt32 = 0

  var extendedMemoryAvailable: UInt32 = 0

  var dataMemoryInstalled: UInt32 = 0

  var dataMemoryUsed: UInt32 = 0

  var dataMemoryConsumption: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_BatteryStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var voltage: UInt32 = 0

  var percentage: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_PowerStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var battery: FkApp_BatteryStatus {
    get {return _storage._battery ?? FkApp_BatteryStatus()}
    set {_uniqueStorage()._battery = newValue}
  }
  /// Returns true if `battery` has been explicitly set.
  var hasBattery: Bool {return _storage._battery != nil}
  /// Clears the value of `battery`. Subsequent reads from it will return its default value.
  mutating func clearBattery() {_uniqueStorage()._battery = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct FkApp_Status {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: UInt32 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  var uptime: UInt32 {
    get {return _storage._uptime}
    set {_uniqueStorage()._uptime = newValue}
  }

  var identity: FkApp_Identity {
    get {return _storage._identity ?? FkApp_Identity()}
    set {_uniqueStorage()._identity = newValue}
  }
  /// Returns true if `identity` has been explicitly set.
  var hasIdentity: Bool {return _storage._identity != nil}
  /// Clears the value of `identity`. Subsequent reads from it will return its default value.
  mutating func clearIdentity() {_uniqueStorage()._identity = nil}

  var hardware: FkApp_HardwareStatus {
    get {return _storage._hardware ?? FkApp_HardwareStatus()}
    set {_uniqueStorage()._hardware = newValue}
  }
  /// Returns true if `hardware` has been explicitly set.
  var hasHardware: Bool {return _storage._hardware != nil}
  /// Clears the value of `hardware`. Subsequent reads from it will return its default value.
  mutating func clearHardware() {_uniqueStorage()._hardware = nil}

  var power: FkApp_PowerStatus {
    get {return _storage._power ?? FkApp_PowerStatus()}
    set {_uniqueStorage()._power = newValue}
  }
  /// Returns true if `power` has been explicitly set.
  var hasPower: Bool {return _storage._power != nil}
  /// Clears the value of `power`. Subsequent reads from it will return its default value.
  mutating func clearPower() {_uniqueStorage()._power = nil}

  var memory: FkApp_MemoryStatus {
    get {return _storage._memory ?? FkApp_MemoryStatus()}
    set {_uniqueStorage()._memory = newValue}
  }
  /// Returns true if `memory` has been explicitly set.
  var hasMemory: Bool {return _storage._memory != nil}
  /// Clears the value of `memory`. Subsequent reads from it will return its default value.
  mutating func clearMemory() {_uniqueStorage()._memory = nil}

  var gps: FkApp_GpsStatus {
    get {return _storage._gps ?? FkApp_GpsStatus()}
    set {_uniqueStorage()._gps = newValue}
  }
  /// Returns true if `gps` has been explicitly set.
  var hasGps: Bool {return _storage._gps != nil}
  /// Clears the value of `gps`. Subsequent reads from it will return its default value.
  mutating func clearGps() {_uniqueStorage()._gps = nil}

  var schedules: FkApp_Schedules {
    get {return _storage._schedules ?? FkApp_Schedules()}
    set {_uniqueStorage()._schedules = newValue}
  }
  /// Returns true if `schedules` has been explicitly set.
  var hasSchedules: Bool {return _storage._schedules != nil}
  /// Clears the value of `schedules`. Subsequent reads from it will return its default value.
  mutating func clearSchedules() {_uniqueStorage()._schedules = nil}

  var recording: FkApp_Recording {
    get {return _storage._recording ?? FkApp_Recording()}
    set {_uniqueStorage()._recording = newValue}
  }
  /// Returns true if `recording` has been explicitly set.
  var hasRecording: Bool {return _storage._recording != nil}
  /// Clears the value of `recording`. Subsequent reads from it will return its default value.
  mutating func clearRecording() {_uniqueStorage()._recording = nil}

  var network: FkApp_NetworkSettings {
    get {return _storage._network ?? FkApp_NetworkSettings()}
    set {_uniqueStorage()._network = newValue}
  }
  /// Returns true if `network` has been explicitly set.
  var hasNetwork: Bool {return _storage._network != nil}
  /// Clears the value of `network`. Subsequent reads from it will return its default value.
  mutating func clearNetwork() {_uniqueStorage()._network = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct FkApp_Range {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var start: UInt32 = 0

  var end: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_DownloadQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var stream: UInt32 = 0

  var ranges: [FkApp_Range] = []

  var blocks: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_Recording {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var modifying: Bool = false

  var enabled: Bool = false

  var startedTime: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_LoraSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var available: Bool = false

  var modifying: Bool = false

  var deviceEui: Data = SwiftProtobuf.Internal.emptyData

  var appKey: Data = SwiftProtobuf.Internal.emptyData

  var appEui: Data = SwiftProtobuf.Internal.emptyData

  var frequencyBand: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_HttpQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: FkApp_QueryType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var identity: FkApp_Identity {
    get {return _storage._identity ?? FkApp_Identity()}
    set {_uniqueStorage()._identity = newValue}
  }
  /// Returns true if `identity` has been explicitly set.
  var hasIdentity: Bool {return _storage._identity != nil}
  /// Clears the value of `identity`. Subsequent reads from it will return its default value.
  mutating func clearIdentity() {_uniqueStorage()._identity = nil}

  var recording: FkApp_Recording {
    get {return _storage._recording ?? FkApp_Recording()}
    set {_uniqueStorage()._recording = newValue}
  }
  /// Returns true if `recording` has been explicitly set.
  var hasRecording: Bool {return _storage._recording != nil}
  /// Clears the value of `recording`. Subsequent reads from it will return its default value.
  mutating func clearRecording() {_uniqueStorage()._recording = nil}

  var schedules: FkApp_Schedules {
    get {return _storage._schedules ?? FkApp_Schedules()}
    set {_uniqueStorage()._schedules = newValue}
  }
  /// Returns true if `schedules` has been explicitly set.
  var hasSchedules: Bool {return _storage._schedules != nil}
  /// Clears the value of `schedules`. Subsequent reads from it will return its default value.
  mutating func clearSchedules() {_uniqueStorage()._schedules = nil}

  var networkSettings: FkApp_NetworkSettings {
    get {return _storage._networkSettings ?? FkApp_NetworkSettings()}
    set {_uniqueStorage()._networkSettings = newValue}
  }
  /// Returns true if `networkSettings` has been explicitly set.
  var hasNetworkSettings: Bool {return _storage._networkSettings != nil}
  /// Clears the value of `networkSettings`. Subsequent reads from it will return its default value.
  mutating func clearNetworkSettings() {_uniqueStorage()._networkSettings = nil}

  var loraSettings: FkApp_LoraSettings {
    get {return _storage._loraSettings ?? FkApp_LoraSettings()}
    set {_uniqueStorage()._loraSettings = newValue}
  }
  /// Returns true if `loraSettings` has been explicitly set.
  var hasLoraSettings: Bool {return _storage._loraSettings != nil}
  /// Clears the value of `loraSettings`. Subsequent reads from it will return its default value.
  mutating func clearLoraSettings() {_uniqueStorage()._loraSettings = nil}

  var flags: UInt32 {
    get {return _storage._flags}
    set {_uniqueStorage()._flags = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct FkApp_DataStream {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt32 = 0

  var time: UInt64 = 0

  var size: UInt64 = 0

  var version: UInt32 = 0

  var block: UInt64 = 0

  var hash: Data = SwiftProtobuf.Internal.emptyData

  var name: String = String()

  var path: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_LiveSensorReading {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sensor: FkApp_SensorCapabilities {
    get {return _storage._sensor ?? FkApp_SensorCapabilities()}
    set {_uniqueStorage()._sensor = newValue}
  }
  /// Returns true if `sensor` has been explicitly set.
  var hasSensor: Bool {return _storage._sensor != nil}
  /// Clears the value of `sensor`. Subsequent reads from it will return its default value.
  mutating func clearSensor() {_uniqueStorage()._sensor = nil}

  var value: Float {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct FkApp_LiveModuleReadings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var module: FkApp_ModuleCapabilities {
    get {return _storage._module ?? FkApp_ModuleCapabilities()}
    set {_uniqueStorage()._module = newValue}
  }
  /// Returns true if `module` has been explicitly set.
  var hasModule: Bool {return _storage._module != nil}
  /// Clears the value of `module`. Subsequent reads from it will return its default value.
  mutating func clearModule() {_uniqueStorage()._module = nil}

  var readings: [FkApp_LiveSensorReading] {
    get {return _storage._readings}
    set {_uniqueStorage()._readings = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct FkApp_LiveReadings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var time: UInt64 = 0

  var modules: [FkApp_LiveModuleReadings] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct FkApp_HttpReply {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: FkApp_ReplyType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var errors: [FkApp_Error] {
    get {return _storage._errors}
    set {_uniqueStorage()._errors = newValue}
  }

  var status: FkApp_Status {
    get {return _storage._status ?? FkApp_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {_uniqueStorage()._status = nil}

  var networkSettings: FkApp_NetworkSettings {
    get {return _storage._networkSettings ?? FkApp_NetworkSettings()}
    set {_uniqueStorage()._networkSettings = newValue}
  }
  /// Returns true if `networkSettings` has been explicitly set.
  var hasNetworkSettings: Bool {return _storage._networkSettings != nil}
  /// Clears the value of `networkSettings`. Subsequent reads from it will return its default value.
  mutating func clearNetworkSettings() {_uniqueStorage()._networkSettings = nil}

  var loraSettings: FkApp_LoraSettings {
    get {return _storage._loraSettings ?? FkApp_LoraSettings()}
    set {_uniqueStorage()._loraSettings = newValue}
  }
  /// Returns true if `loraSettings` has been explicitly set.
  var hasLoraSettings: Bool {return _storage._loraSettings != nil}
  /// Clears the value of `loraSettings`. Subsequent reads from it will return its default value.
  mutating func clearLoraSettings() {_uniqueStorage()._loraSettings = nil}

  var modules: [FkApp_ModuleCapabilities] {
    get {return _storage._modules}
    set {_uniqueStorage()._modules = newValue}
  }

  var streams: [FkApp_DataStream] {
    get {return _storage._streams}
    set {_uniqueStorage()._streams = newValue}
  }

  var liveReadings: [FkApp_LiveReadings] {
    get {return _storage._liveReadings}
    set {_uniqueStorage()._liveReadings = newValue}
  }

  var schedules: FkApp_Schedules {
    get {return _storage._schedules ?? FkApp_Schedules()}
    set {_uniqueStorage()._schedules = newValue}
  }
  /// Returns true if `schedules` has been explicitly set.
  var hasSchedules: Bool {return _storage._schedules != nil}
  /// Clears the value of `schedules`. Subsequent reads from it will return its default value.
  mutating func clearSchedules() {_uniqueStorage()._schedules = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "fk_app"

extension FkApp_QueryType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "QUERY_NONE"),
    1: .same(proto: "QUERY_CAPABILITIES"),
    2: .same(proto: "QUERY_CONFIGURE_SENSOR"),
    7: .same(proto: "QUERY_LIVE_DATA_POLL"),
    8: .same(proto: "QUERY_SCHEDULES"),
    9: .same(proto: "QUERY_CONFIGUE_SCHEDULES"),
    10: .same(proto: "QUERY_FILES"),
    11: .same(proto: "QUERY_DOWNLOAD_FILE"),
    12: .same(proto: "QUERY_ERASE_FILE"),
    13: .same(proto: "QUERY_RESET"),
    14: .same(proto: "QUERY_NETWORK_SETTINGS"),
    15: .same(proto: "QUERY_CONFIGURE_NETWORK_SETTINGS"),
    16: .same(proto: "QUERY_IDENTITY"),
    17: .same(proto: "QUERY_CONFIGURE_IDENTITY"),
    18: .same(proto: "QUERY_STATUS"),
    19: .same(proto: "QUERY_MODULE"),
    20: .same(proto: "QUERY_METADATA"),
    21: .same(proto: "QUERY_FORMAT"),
    22: .same(proto: "QUERY_GET_READINGS"),
    23: .same(proto: "QUERY_TAKE_READINGS"),
    24: .same(proto: "QUERY_RECORDING_CONTROL"),
    25: .same(proto: "QUERY_CONFIGURE"),
  ]
}

extension FkApp_ReplyType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REPLY_NONE"),
    1: .same(proto: "REPLY_SUCCESS"),
    2: .same(proto: "REPLY_BUSY"),
    3: .same(proto: "REPLY_ERROR"),
    4: .same(proto: "REPLY_CAPABILITIES"),
    8: .same(proto: "REPLY_LIVE_DATA_POLL"),
    9: .same(proto: "REPLY_SCHEDULES"),
    10: .same(proto: "REPLY_FILES"),
    11: .same(proto: "REPLY_DOWNLOAD_FILE"),
    12: .same(proto: "REPLY_RESET"),
    13: .same(proto: "REPLY_NETWORK_SETTINGS"),
    14: .same(proto: "REPLY_IDENTITY"),
    15: .same(proto: "REPLY_STATUS"),
    16: .same(proto: "REPLY_MODULE"),
    17: .same(proto: "REPLY_METADATA"),
    18: .same(proto: "REPLY_READINGS"),
  ]
}

extension FkApp_DownloadFlags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DOWNLOAD_FLAG_NONE"),
    1: .same(proto: "DOWNLOAD_FLAG_METADATA_PREPEND"),
    2: .same(proto: "DOWNLOAD_FLAG_METADATA_ONLY"),
  ]
}

extension FkApp_ModuleFlags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MODULE_FLAG_NONE"),
    1: .same(proto: "MODULE_FLAG_INTERNAL"),
  ]
}

extension FkApp_SensorFlags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SENSOR_FLAG_NONE"),
  ]
}

extension FkApp_QueryCapabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryCapabilities"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "callerTime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.version)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.callerTime)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 1)
    }
    if self.callerTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.callerTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_QueryCapabilities, rhs: FkApp_QueryCapabilities) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.callerTime != rhs.callerTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_LiveValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LiveValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "valid"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.valid)
      case 2: try decoder.decodeSingularFloatField(value: &self.value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.valid != false {
      try visitor.visitSingularBoolField(value: self.valid, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_LiveValue, rhs: FkApp_LiveValue) -> Bool {
    if lhs.valid != rhs.valid {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_SensorCapabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SensorCapabilities"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "number"),
    2: .same(proto: "module"),
    3: .same(proto: "name"),
    4: .same(proto: "frequency"),
    5: .same(proto: "unitOfMeasure"),
    6: .same(proto: "path"),
    7: .same(proto: "flags"),
    8: .same(proto: "value"),
  ]

  fileprivate class _StorageClass {
    var _number: UInt32 = 0
    var _module: UInt32 = 0
    var _name: String = String()
    var _frequency: UInt32 = 0
    var _unitOfMeasure: String = String()
    var _path: String = String()
    var _flags: UInt32 = 0
    var _value: FkApp_LiveValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _number = source._number
      _module = source._module
      _name = source._name
      _frequency = source._frequency
      _unitOfMeasure = source._unitOfMeasure
      _path = source._path
      _flags = source._flags
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._number)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._module)
        case 3: try decoder.decodeSingularStringField(value: &_storage._name)
        case 4: try decoder.decodeSingularUInt32Field(value: &_storage._frequency)
        case 5: try decoder.decodeSingularStringField(value: &_storage._unitOfMeasure)
        case 6: try decoder.decodeSingularStringField(value: &_storage._path)
        case 7: try decoder.decodeSingularUInt32Field(value: &_storage._flags)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._value)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._number != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._number, fieldNumber: 1)
      }
      if _storage._module != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._module, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if _storage._frequency != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._frequency, fieldNumber: 4)
      }
      if !_storage._unitOfMeasure.isEmpty {
        try visitor.visitSingularStringField(value: _storage._unitOfMeasure, fieldNumber: 5)
      }
      if !_storage._path.isEmpty {
        try visitor.visitSingularStringField(value: _storage._path, fieldNumber: 6)
      }
      if _storage._flags != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._flags, fieldNumber: 7)
      }
      if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_SensorCapabilities, rhs: FkApp_SensorCapabilities) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._number != rhs_storage._number {return false}
        if _storage._module != rhs_storage._module {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._frequency != rhs_storage._frequency {return false}
        if _storage._unitOfMeasure != rhs_storage._unitOfMeasure {return false}
        if _storage._path != rhs_storage._path {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._value != rhs_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_ModuleCapabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModuleCapabilities"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .same(proto: "name"),
    3: .same(proto: "sensors"),
    4: .same(proto: "path"),
    5: .same(proto: "flags"),
    6: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.position)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.sensors)
      case 4: try decoder.decodeSingularStringField(value: &self.path)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.flags)
      case 6: try decoder.decodeSingularBytesField(value: &self.id)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.position != 0 {
      try visitor.visitSingularUInt32Field(value: self.position, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.sensors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sensors, fieldNumber: 3)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 4)
    }
    if self.flags != 0 {
      try visitor.visitSingularUInt32Field(value: self.flags, fieldNumber: 5)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_ModuleCapabilities, rhs: FkApp_ModuleCapabilities) -> Bool {
    if lhs.position != rhs.position {return false}
    if lhs.name != rhs.name {return false}
    if lhs.sensors != rhs.sensors {return false}
    if lhs.path != rhs.path {return false}
    if lhs.flags != rhs.flags {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_Capabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Capabilities"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "deviceId"),
    3: .same(proto: "name"),
    4: .same(proto: "modules"),
    5: .same(proto: "sensors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.version)
      case 2: try decoder.decodeSingularBytesField(value: &self.deviceID)
      case 3: try decoder.decodeSingularStringField(value: &self.name)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.modules)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.sensors)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 1)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.modules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modules, fieldNumber: 4)
    }
    if !self.sensors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sensors, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_Capabilities, rhs: FkApp_Capabilities) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.modules != rhs.modules {return false}
    if lhs.sensors != rhs.sensors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_NetworkInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ssid"),
    2: .same(proto: "password"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.ssid)
      case 2: try decoder.decodeSingularStringField(value: &self.password)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ssid.isEmpty {
      try visitor.visitSingularStringField(value: self.ssid, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_NetworkInfo, rhs: FkApp_NetworkInfo) -> Bool {
    if lhs.ssid != rhs.ssid {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_NetworkSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "createAccessPoint"),
    2: .same(proto: "networks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.createAccessPoint)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.networks)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.createAccessPoint != 0 {
      try visitor.visitSingularInt32Field(value: self.createAccessPoint, fieldNumber: 1)
    }
    if !self.networks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.networks, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_NetworkSettings, rhs: FkApp_NetworkSettings) -> Bool {
    if lhs.createAccessPoint != rhs.createAccessPoint {return false}
    if lhs.networks != rhs.networks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_Firmware: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Firmware"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "git"),
    2: .same(proto: "build"),
    3: .same(proto: "number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.git)
      case 2: try decoder.decodeSingularStringField(value: &self.build)
      case 3: try decoder.decodeSingularStringField(value: &self.number)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.git.isEmpty {
      try visitor.visitSingularStringField(value: self.git, fieldNumber: 1)
    }
    if !self.build.isEmpty {
      try visitor.visitSingularStringField(value: self.build, fieldNumber: 2)
    }
    if !self.number.isEmpty {
      try visitor.visitSingularStringField(value: self.number, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_Firmware, rhs: FkApp_Firmware) -> Bool {
    if lhs.git != rhs.git {return false}
    if lhs.build != rhs.build {return false}
    if lhs.number != rhs.number {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_Identity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Identity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "device"),
    2: .same(proto: "stream"),
    3: .same(proto: "deviceId"),
    4: .same(proto: "firmware"),
    5: .same(proto: "build"),
    8: .same(proto: "number"),
    6: .same(proto: "name"),
    7: .same(proto: "generation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.device)
      case 2: try decoder.decodeSingularStringField(value: &self.stream)
      case 3: try decoder.decodeSingularBytesField(value: &self.deviceID)
      case 4: try decoder.decodeSingularStringField(value: &self.firmware)
      case 5: try decoder.decodeSingularStringField(value: &self.build)
      case 6: try decoder.decodeSingularStringField(value: &self.name)
      case 7: try decoder.decodeSingularBytesField(value: &self.generation)
      case 8: try decoder.decodeSingularStringField(value: &self.number)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.device.isEmpty {
      try visitor.visitSingularStringField(value: self.device, fieldNumber: 1)
    }
    if !self.stream.isEmpty {
      try visitor.visitSingularStringField(value: self.stream, fieldNumber: 2)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceID, fieldNumber: 3)
    }
    if !self.firmware.isEmpty {
      try visitor.visitSingularStringField(value: self.firmware, fieldNumber: 4)
    }
    if !self.build.isEmpty {
      try visitor.visitSingularStringField(value: self.build, fieldNumber: 5)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    if !self.generation.isEmpty {
      try visitor.visitSingularBytesField(value: self.generation, fieldNumber: 7)
    }
    if !self.number.isEmpty {
      try visitor.visitSingularStringField(value: self.number, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_Identity, rhs: FkApp_Identity) -> Bool {
    if lhs.device != rhs.device {return false}
    if lhs.stream != rhs.stream {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.firmware != rhs.firmware {return false}
    if lhs.build != rhs.build {return false}
    if lhs.number != rhs.number {return false}
    if lhs.name != rhs.name {return false}
    if lhs.generation != rhs.generation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_ConfigureSensorQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfigureSensorQuery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "frequency"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.id)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.frequency)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.frequency != 0 {
      try visitor.visitSingularUInt32Field(value: self.frequency, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_ConfigureSensorQuery, rhs: FkApp_ConfigureSensorQuery) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.frequency != rhs.frequency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_LiveDataPoll: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LiveDataPoll"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "interval"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.interval)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.interval != 0 {
      try visitor.visitSingularUInt32Field(value: self.interval, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_LiveDataPoll, rhs: FkApp_LiveDataPoll) -> Bool {
    if lhs.interval != rhs.interval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_LiveDataSample: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LiveDataSample"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sensor"),
    2: .same(proto: "time"),
    3: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.sensor)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.time)
      case 3: try decoder.decodeSingularFloatField(value: &self.value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sensor != 0 {
      try visitor.visitSingularUInt32Field(value: self.sensor, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularUInt64Field(value: self.time, fieldNumber: 2)
    }
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_LiveDataSample, rhs: FkApp_LiveDataSample) -> Bool {
    if lhs.sensor != rhs.sensor {return false}
    if lhs.time != rhs.time {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_LiveData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LiveData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "samples"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.samples)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.samples.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.samples, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_LiveData, rhs: FkApp_LiveData) -> Bool {
    if lhs.samples != rhs.samples {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".File"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "time"),
    3: .same(proto: "size"),
    4: .same(proto: "version"),
    5: .same(proto: "name"),
    6: .same(proto: "maximum"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.id)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.time)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.size)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.version)
      case 5: try decoder.decodeSingularStringField(value: &self.name)
      case 6: try decoder.decodeSingularUInt64Field(value: &self.maximum)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularUInt64Field(value: self.time, fieldNumber: 2)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt64Field(value: self.size, fieldNumber: 3)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    if self.maximum != 0 {
      try visitor.visitSingularUInt64Field(value: self.maximum, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_File, rhs: FkApp_File) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.time != rhs.time {return false}
    if lhs.size != rhs.size {return false}
    if lhs.version != rhs.version {return false}
    if lhs.name != rhs.name {return false}
    if lhs.maximum != rhs.maximum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_Files: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Files"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "files"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.files)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.files.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.files, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_Files, rhs: FkApp_Files) -> Bool {
    if lhs.files != rhs.files {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_DownloadFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DownloadFile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "offset"),
    3: .same(proto: "length"),
    4: .same(proto: "flags"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.id)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.offset)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.length)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.flags)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularUInt32Field(value: self.offset, fieldNumber: 2)
    }
    if self.length != 0 {
      try visitor.visitSingularUInt32Field(value: self.length, fieldNumber: 3)
    }
    if self.flags != 0 {
      try visitor.visitSingularUInt32Field(value: self.flags, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_DownloadFile, rhs: FkApp_DownloadFile) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.length != rhs.length {return false}
    if lhs.flags != rhs.flags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_EraseFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EraseFile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.id)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_EraseFile, rhs: FkApp_EraseFile) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_FileData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "offset"),
    2: .same(proto: "data"),
    3: .same(proto: "size"),
    4: .same(proto: "hash"),
    5: .same(proto: "version"),
    6: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.offset)
      case 2: try decoder.decodeSingularBytesField(value: &self.data)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.size)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.hash)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.version)
      case 6: try decoder.decodeSingularUInt32Field(value: &self.id)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.offset != 0 {
      try visitor.visitSingularUInt32Field(value: self.offset, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt32Field(value: self.size, fieldNumber: 3)
    }
    if self.hash != 0 {
      try visitor.visitSingularUInt32Field(value: self.hash, fieldNumber: 4)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 5)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_FileData, rhs: FkApp_FileData) -> Bool {
    if lhs.offset != rhs.offset {return false}
    if lhs.data != rhs.data {return false}
    if lhs.size != rhs.size {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.version != rhs.version {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_DeviceStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uptime"),
    2: .same(proto: "batteryPercentage"),
    3: .same(proto: "batteryVoltage"),
    4: .same(proto: "gpsHasFix"),
    5: .same(proto: "gpsSatellites"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.uptime)
      case 2: try decoder.decodeSingularFloatField(value: &self.batteryPercentage)
      case 3: try decoder.decodeSingularFloatField(value: &self.batteryVoltage)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.gpsHasFix)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.gpsSatellites)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uptime != 0 {
      try visitor.visitSingularUInt32Field(value: self.uptime, fieldNumber: 1)
    }
    if self.batteryPercentage != 0 {
      try visitor.visitSingularFloatField(value: self.batteryPercentage, fieldNumber: 2)
    }
    if self.batteryVoltage != 0 {
      try visitor.visitSingularFloatField(value: self.batteryVoltage, fieldNumber: 3)
    }
    if self.gpsHasFix != 0 {
      try visitor.visitSingularUInt32Field(value: self.gpsHasFix, fieldNumber: 4)
    }
    if self.gpsSatellites != 0 {
      try visitor.visitSingularUInt32Field(value: self.gpsSatellites, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_DeviceStatus, rhs: FkApp_DeviceStatus) -> Bool {
    if lhs.uptime != rhs.uptime {return false}
    if lhs.batteryPercentage != rhs.batteryPercentage {return false}
    if lhs.batteryVoltage != rhs.batteryVoltage {return false}
    if lhs.gpsHasFix != rhs.gpsHasFix {return false}
    if lhs.gpsSatellites != rhs.gpsSatellites {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_QueryModule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryModule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "address"),
    3: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.id)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.address)
      case 3: try decoder.decodeSingularBytesField(value: &self.message)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.address != 0 {
      try visitor.visitSingularUInt32Field(value: self.address, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularBytesField(value: self.message, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_QueryModule, rhs: FkApp_QueryModule) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.address != rhs.address {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_ModuleReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModuleReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "address"),
    3: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.id)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.address)
      case 3: try decoder.decodeSingularBytesField(value: &self.message)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.address != 0 {
      try visitor.visitSingularUInt32Field(value: self.address, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularBytesField(value: self.message, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_ModuleReply, rhs: FkApp_ModuleReply) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.address != rhs.address {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_WireMessageQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WireMessageQuery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "queryCapabilities"),
    3: .same(proto: "configureSensor"),
    8: .same(proto: "liveDataPoll"),
    10: .same(proto: "downloadFile"),
    11: .same(proto: "eraseFile"),
    12: .same(proto: "networkSettings"),
    13: .same(proto: "identity"),
    14: .same(proto: "module"),
  ]

  fileprivate class _StorageClass {
    var _type: FkApp_QueryType = .queryNone
    var _queryCapabilities: FkApp_QueryCapabilities? = nil
    var _configureSensor: FkApp_ConfigureSensorQuery? = nil
    var _liveDataPoll: FkApp_LiveDataPoll? = nil
    var _downloadFile: FkApp_DownloadFile? = nil
    var _eraseFile: FkApp_EraseFile? = nil
    var _networkSettings: FkApp_NetworkSettings? = nil
    var _identity: FkApp_Identity? = nil
    var _module: FkApp_QueryModule? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _queryCapabilities = source._queryCapabilities
      _configureSensor = source._configureSensor
      _liveDataPoll = source._liveDataPoll
      _downloadFile = source._downloadFile
      _eraseFile = source._eraseFile
      _networkSettings = source._networkSettings
      _identity = source._identity
      _module = source._module
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._queryCapabilities)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._configureSensor)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._liveDataPoll)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._downloadFile)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._eraseFile)
        case 12: try decoder.decodeSingularMessageField(value: &_storage._networkSettings)
        case 13: try decoder.decodeSingularMessageField(value: &_storage._identity)
        case 14: try decoder.decodeSingularMessageField(value: &_storage._module)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type != .queryNone {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if let v = _storage._queryCapabilities {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._configureSensor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._liveDataPoll {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._downloadFile {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._eraseFile {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._networkSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._identity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._module {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_WireMessageQuery, rhs: FkApp_WireMessageQuery) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._queryCapabilities != rhs_storage._queryCapabilities {return false}
        if _storage._configureSensor != rhs_storage._configureSensor {return false}
        if _storage._liveDataPoll != rhs_storage._liveDataPoll {return false}
        if _storage._downloadFile != rhs_storage._downloadFile {return false}
        if _storage._eraseFile != rhs_storage._eraseFile {return false}
        if _storage._networkSettings != rhs_storage._networkSettings {return false}
        if _storage._identity != rhs_storage._identity {return false}
        if _storage._module != rhs_storage._module {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Error"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "delay"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.message)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.delay)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if self.delay != 0 {
      try visitor.visitSingularUInt32Field(value: self.delay, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_Error, rhs: FkApp_Error) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.delay != rhs.delay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_WireMessageReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WireMessageReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "errors"),
    3: .same(proto: "capabilities"),
    6: .same(proto: "liveData"),
    8: .same(proto: "files"),
    9: .same(proto: "fileData"),
    10: .same(proto: "networkSettings"),
    11: .same(proto: "identity"),
    12: .same(proto: "status"),
    13: .same(proto: "module"),
  ]

  fileprivate class _StorageClass {
    var _type: FkApp_ReplyType = .replyNone
    var _errors: [FkApp_Error] = []
    var _capabilities: FkApp_Capabilities? = nil
    var _liveData: FkApp_LiveData? = nil
    var _files: FkApp_Files? = nil
    var _fileData: FkApp_FileData? = nil
    var _networkSettings: FkApp_NetworkSettings? = nil
    var _identity: FkApp_Identity? = nil
    var _status: FkApp_DeviceStatus? = nil
    var _module: FkApp_ModuleReply? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _errors = source._errors
      _capabilities = source._capabilities
      _liveData = source._liveData
      _files = source._files
      _fileData = source._fileData
      _networkSettings = source._networkSettings
      _identity = source._identity
      _status = source._status
      _module = source._module
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._errors)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._capabilities)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._liveData)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._files)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._fileData)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._networkSettings)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._identity)
        case 12: try decoder.decodeSingularMessageField(value: &_storage._status)
        case 13: try decoder.decodeSingularMessageField(value: &_storage._module)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type != .replyNone {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if !_storage._errors.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._errors, fieldNumber: 2)
      }
      if let v = _storage._capabilities {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._liveData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._files {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._fileData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._networkSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._identity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._module {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_WireMessageReply, rhs: FkApp_WireMessageReply) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._errors != rhs_storage._errors {return false}
        if _storage._capabilities != rhs_storage._capabilities {return false}
        if _storage._liveData != rhs_storage._liveData {return false}
        if _storage._files != rhs_storage._files {return false}
        if _storage._fileData != rhs_storage._fileData {return false}
        if _storage._networkSettings != rhs_storage._networkSettings {return false}
        if _storage._identity != rhs_storage._identity {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._module != rhs_storage._module {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_Schedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Schedule"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cron"),
    2: .same(proto: "interval"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.cron)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.interval)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cron.isEmpty {
      try visitor.visitSingularBytesField(value: self.cron, fieldNumber: 1)
    }
    if self.interval != 0 {
      try visitor.visitSingularUInt32Field(value: self.interval, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_Schedule, rhs: FkApp_Schedule) -> Bool {
    if lhs.cron != rhs.cron {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_Schedules: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Schedules"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "modifying"),
    2: .same(proto: "readings"),
    3: .same(proto: "lora"),
    4: .same(proto: "network"),
    5: .same(proto: "gps"),
  ]

  fileprivate class _StorageClass {
    var _modifying: Bool = false
    var _readings: FkApp_Schedule? = nil
    var _lora: FkApp_Schedule? = nil
    var _network: FkApp_Schedule? = nil
    var _gps: FkApp_Schedule? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _modifying = source._modifying
      _readings = source._readings
      _lora = source._lora
      _network = source._network
      _gps = source._gps
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBoolField(value: &_storage._modifying)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._readings)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._lora)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._network)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._gps)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._modifying != false {
        try visitor.visitSingularBoolField(value: _storage._modifying, fieldNumber: 1)
      }
      if let v = _storage._readings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._lora {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._network {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._gps {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_Schedules, rhs: FkApp_Schedules) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._modifying != rhs_storage._modifying {return false}
        if _storage._readings != rhs_storage._readings {return false}
        if _storage._lora != rhs_storage._lora {return false}
        if _storage._network != rhs_storage._network {return false}
        if _storage._gps != rhs_storage._gps {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_HardwareStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HardwareStatus"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_HardwareStatus, rhs: FkApp_HardwareStatus) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_GpsStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GpsStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    7: .same(proto: "enabled"),
    1: .same(proto: "fix"),
    2: .same(proto: "time"),
    3: .same(proto: "satellites"),
    4: .same(proto: "longitude"),
    5: .same(proto: "latitude"),
    6: .same(proto: "altitude"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.fix)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.time)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.satellites)
      case 4: try decoder.decodeSingularFloatField(value: &self.longitude)
      case 5: try decoder.decodeSingularFloatField(value: &self.latitude)
      case 6: try decoder.decodeSingularFloatField(value: &self.altitude)
      case 7: try decoder.decodeSingularUInt32Field(value: &self.enabled)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fix != 0 {
      try visitor.visitSingularUInt32Field(value: self.fix, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularUInt64Field(value: self.time, fieldNumber: 2)
    }
    if self.satellites != 0 {
      try visitor.visitSingularUInt32Field(value: self.satellites, fieldNumber: 3)
    }
    if self.longitude != 0 {
      try visitor.visitSingularFloatField(value: self.longitude, fieldNumber: 4)
    }
    if self.latitude != 0 {
      try visitor.visitSingularFloatField(value: self.latitude, fieldNumber: 5)
    }
    if self.altitude != 0 {
      try visitor.visitSingularFloatField(value: self.altitude, fieldNumber: 6)
    }
    if self.enabled != 0 {
      try visitor.visitSingularUInt32Field(value: self.enabled, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_GpsStatus, rhs: FkApp_GpsStatus) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.fix != rhs.fix {return false}
    if lhs.time != rhs.time {return false}
    if lhs.satellites != rhs.satellites {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.altitude != rhs.altitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_MemoryStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MemoryStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sramAvailable"),
    2: .same(proto: "programFlashAvailable"),
    3: .same(proto: "extendedMemoryAvailable"),
    4: .same(proto: "dataMemoryInstalled"),
    5: .same(proto: "dataMemoryUsed"),
    6: .same(proto: "dataMemoryConsumption"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.sramAvailable)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.programFlashAvailable)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.extendedMemoryAvailable)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.dataMemoryInstalled)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.dataMemoryUsed)
      case 6: try decoder.decodeSingularFloatField(value: &self.dataMemoryConsumption)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sramAvailable != 0 {
      try visitor.visitSingularUInt32Field(value: self.sramAvailable, fieldNumber: 1)
    }
    if self.programFlashAvailable != 0 {
      try visitor.visitSingularUInt32Field(value: self.programFlashAvailable, fieldNumber: 2)
    }
    if self.extendedMemoryAvailable != 0 {
      try visitor.visitSingularUInt32Field(value: self.extendedMemoryAvailable, fieldNumber: 3)
    }
    if self.dataMemoryInstalled != 0 {
      try visitor.visitSingularUInt32Field(value: self.dataMemoryInstalled, fieldNumber: 4)
    }
    if self.dataMemoryUsed != 0 {
      try visitor.visitSingularUInt32Field(value: self.dataMemoryUsed, fieldNumber: 5)
    }
    if self.dataMemoryConsumption != 0 {
      try visitor.visitSingularFloatField(value: self.dataMemoryConsumption, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_MemoryStatus, rhs: FkApp_MemoryStatus) -> Bool {
    if lhs.sramAvailable != rhs.sramAvailable {return false}
    if lhs.programFlashAvailable != rhs.programFlashAvailable {return false}
    if lhs.extendedMemoryAvailable != rhs.extendedMemoryAvailable {return false}
    if lhs.dataMemoryInstalled != rhs.dataMemoryInstalled {return false}
    if lhs.dataMemoryUsed != rhs.dataMemoryUsed {return false}
    if lhs.dataMemoryConsumption != rhs.dataMemoryConsumption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_BatteryStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatteryStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "voltage"),
    2: .same(proto: "percentage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.voltage)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.percentage)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.voltage != 0 {
      try visitor.visitSingularUInt32Field(value: self.voltage, fieldNumber: 1)
    }
    if self.percentage != 0 {
      try visitor.visitSingularUInt32Field(value: self.percentage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_BatteryStatus, rhs: FkApp_BatteryStatus) -> Bool {
    if lhs.voltage != rhs.voltage {return false}
    if lhs.percentage != rhs.percentage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_PowerStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PowerStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "battery"),
  ]

  fileprivate class _StorageClass {
    var _battery: FkApp_BatteryStatus? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _battery = source._battery
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._battery)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._battery {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_PowerStatus, rhs: FkApp_PowerStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._battery != rhs_storage._battery {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_Status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Status"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "uptime"),
    3: .same(proto: "identity"),
    4: .same(proto: "hardware"),
    5: .same(proto: "power"),
    6: .same(proto: "memory"),
    7: .same(proto: "gps"),
    8: .same(proto: "schedules"),
    9: .same(proto: "recording"),
    10: .same(proto: "network"),
  ]

  fileprivate class _StorageClass {
    var _version: UInt32 = 0
    var _uptime: UInt32 = 0
    var _identity: FkApp_Identity? = nil
    var _hardware: FkApp_HardwareStatus? = nil
    var _power: FkApp_PowerStatus? = nil
    var _memory: FkApp_MemoryStatus? = nil
    var _gps: FkApp_GpsStatus? = nil
    var _schedules: FkApp_Schedules? = nil
    var _recording: FkApp_Recording? = nil
    var _network: FkApp_NetworkSettings? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _version = source._version
      _uptime = source._uptime
      _identity = source._identity
      _hardware = source._hardware
      _power = source._power
      _memory = source._memory
      _gps = source._gps
      _schedules = source._schedules
      _recording = source._recording
      _network = source._network
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularUInt32Field(value: &_storage._version)
        case 2: try decoder.decodeSingularUInt32Field(value: &_storage._uptime)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._identity)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._hardware)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._power)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._memory)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._gps)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._schedules)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._recording)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._network)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._version != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._version, fieldNumber: 1)
      }
      if _storage._uptime != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._uptime, fieldNumber: 2)
      }
      if let v = _storage._identity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._hardware {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._power {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._memory {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._gps {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._schedules {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._recording {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._network {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_Status, rhs: FkApp_Status) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._version != rhs_storage._version {return false}
        if _storage._uptime != rhs_storage._uptime {return false}
        if _storage._identity != rhs_storage._identity {return false}
        if _storage._hardware != rhs_storage._hardware {return false}
        if _storage._power != rhs_storage._power {return false}
        if _storage._memory != rhs_storage._memory {return false}
        if _storage._gps != rhs_storage._gps {return false}
        if _storage._schedules != rhs_storage._schedules {return false}
        if _storage._recording != rhs_storage._recording {return false}
        if _storage._network != rhs_storage._network {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_Range: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Range"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.start)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.end)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.start != 0 {
      try visitor.visitSingularUInt32Field(value: self.start, fieldNumber: 1)
    }
    if self.end != 0 {
      try visitor.visitSingularUInt32Field(value: self.end, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_Range, rhs: FkApp_Range) -> Bool {
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_DownloadQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DownloadQuery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stream"),
    3: .same(proto: "ranges"),
    4: .same(proto: "blocks"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.stream)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.ranges)
      case 4: try decoder.decodeRepeatedUInt32Field(value: &self.blocks)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.stream != 0 {
      try visitor.visitSingularUInt32Field(value: self.stream, fieldNumber: 1)
    }
    if !self.ranges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ranges, fieldNumber: 3)
    }
    if !self.blocks.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.blocks, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_DownloadQuery, rhs: FkApp_DownloadQuery) -> Bool {
    if lhs.stream != rhs.stream {return false}
    if lhs.ranges != rhs.ranges {return false}
    if lhs.blocks != rhs.blocks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_Recording: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Recording"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "modifying"),
    2: .same(proto: "enabled"),
    3: .standard(proto: "started_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.modifying)
      case 2: try decoder.decodeSingularBoolField(value: &self.enabled)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.startedTime)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.modifying != false {
      try visitor.visitSingularBoolField(value: self.modifying, fieldNumber: 1)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 2)
    }
    if self.startedTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.startedTime, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_Recording, rhs: FkApp_Recording) -> Bool {
    if lhs.modifying != rhs.modifying {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.startedTime != rhs.startedTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_LoraSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoraSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "available"),
    2: .same(proto: "modifying"),
    3: .same(proto: "deviceEui"),
    4: .same(proto: "appKey"),
    5: .same(proto: "appEui"),
    6: .same(proto: "frequencyBand"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.available)
      case 2: try decoder.decodeSingularBoolField(value: &self.modifying)
      case 3: try decoder.decodeSingularBytesField(value: &self.deviceEui)
      case 4: try decoder.decodeSingularBytesField(value: &self.appKey)
      case 5: try decoder.decodeSingularBytesField(value: &self.appEui)
      case 6: try decoder.decodeSingularUInt32Field(value: &self.frequencyBand)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.available != false {
      try visitor.visitSingularBoolField(value: self.available, fieldNumber: 1)
    }
    if self.modifying != false {
      try visitor.visitSingularBoolField(value: self.modifying, fieldNumber: 2)
    }
    if !self.deviceEui.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceEui, fieldNumber: 3)
    }
    if !self.appKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.appKey, fieldNumber: 4)
    }
    if !self.appEui.isEmpty {
      try visitor.visitSingularBytesField(value: self.appEui, fieldNumber: 5)
    }
    if self.frequencyBand != 0 {
      try visitor.visitSingularUInt32Field(value: self.frequencyBand, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_LoraSettings, rhs: FkApp_LoraSettings) -> Bool {
    if lhs.available != rhs.available {return false}
    if lhs.modifying != rhs.modifying {return false}
    if lhs.deviceEui != rhs.deviceEui {return false}
    if lhs.appKey != rhs.appKey {return false}
    if lhs.appEui != rhs.appEui {return false}
    if lhs.frequencyBand != rhs.frequencyBand {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_HttpQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HttpQuery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "identity"),
    3: .same(proto: "recording"),
    4: .same(proto: "schedules"),
    6: .same(proto: "networkSettings"),
    7: .same(proto: "loraSettings"),
    5: .same(proto: "flags"),
  ]

  fileprivate class _StorageClass {
    var _type: FkApp_QueryType = .queryNone
    var _identity: FkApp_Identity? = nil
    var _recording: FkApp_Recording? = nil
    var _schedules: FkApp_Schedules? = nil
    var _networkSettings: FkApp_NetworkSettings? = nil
    var _loraSettings: FkApp_LoraSettings? = nil
    var _flags: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _identity = source._identity
      _recording = source._recording
      _schedules = source._schedules
      _networkSettings = source._networkSettings
      _loraSettings = source._loraSettings
      _flags = source._flags
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._identity)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._recording)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._schedules)
        case 5: try decoder.decodeSingularUInt32Field(value: &_storage._flags)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._networkSettings)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._loraSettings)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type != .queryNone {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if let v = _storage._identity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._recording {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._schedules {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._flags != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._flags, fieldNumber: 5)
      }
      if let v = _storage._networkSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._loraSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_HttpQuery, rhs: FkApp_HttpQuery) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._identity != rhs_storage._identity {return false}
        if _storage._recording != rhs_storage._recording {return false}
        if _storage._schedules != rhs_storage._schedules {return false}
        if _storage._networkSettings != rhs_storage._networkSettings {return false}
        if _storage._loraSettings != rhs_storage._loraSettings {return false}
        if _storage._flags != rhs_storage._flags {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_DataStream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DataStream"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "time"),
    3: .same(proto: "size"),
    4: .same(proto: "version"),
    5: .same(proto: "block"),
    6: .same(proto: "hash"),
    7: .same(proto: "name"),
    8: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.id)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.time)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.size)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.version)
      case 5: try decoder.decodeSingularUInt64Field(value: &self.block)
      case 6: try decoder.decodeSingularBytesField(value: &self.hash)
      case 7: try decoder.decodeSingularStringField(value: &self.name)
      case 8: try decoder.decodeSingularStringField(value: &self.path)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.time != 0 {
      try visitor.visitSingularUInt64Field(value: self.time, fieldNumber: 2)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt64Field(value: self.size, fieldNumber: 3)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 4)
    }
    if self.block != 0 {
      try visitor.visitSingularUInt64Field(value: self.block, fieldNumber: 5)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 6)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 7)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_DataStream, rhs: FkApp_DataStream) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.time != rhs.time {return false}
    if lhs.size != rhs.size {return false}
    if lhs.version != rhs.version {return false}
    if lhs.block != rhs.block {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.name != rhs.name {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_LiveSensorReading: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LiveSensorReading"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sensor"),
    2: .same(proto: "value"),
  ]

  fileprivate class _StorageClass {
    var _sensor: FkApp_SensorCapabilities? = nil
    var _value: Float = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sensor = source._sensor
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._sensor)
        case 2: try decoder.decodeSingularFloatField(value: &_storage._value)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._sensor {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._value != 0 {
        try visitor.visitSingularFloatField(value: _storage._value, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_LiveSensorReading, rhs: FkApp_LiveSensorReading) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sensor != rhs_storage._sensor {return false}
        if _storage._value != rhs_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_LiveModuleReadings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LiveModuleReadings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "module"),
    2: .same(proto: "readings"),
  ]

  fileprivate class _StorageClass {
    var _module: FkApp_ModuleCapabilities? = nil
    var _readings: [FkApp_LiveSensorReading] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _module = source._module
      _readings = source._readings
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._module)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._readings)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._module {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._readings.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._readings, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_LiveModuleReadings, rhs: FkApp_LiveModuleReadings) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._module != rhs_storage._module {return false}
        if _storage._readings != rhs_storage._readings {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_LiveReadings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LiveReadings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "modules"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.time)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.modules)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.time != 0 {
      try visitor.visitSingularUInt64Field(value: self.time, fieldNumber: 1)
    }
    if !self.modules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modules, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_LiveReadings, rhs: FkApp_LiveReadings) -> Bool {
    if lhs.time != rhs.time {return false}
    if lhs.modules != rhs.modules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FkApp_HttpReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HttpReply"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "errors"),
    3: .same(proto: "status"),
    4: .same(proto: "networkSettings"),
    8: .same(proto: "loraSettings"),
    5: .same(proto: "modules"),
    6: .same(proto: "streams"),
    7: .same(proto: "liveReadings"),
    9: .same(proto: "schedules"),
  ]

  fileprivate class _StorageClass {
    var _type: FkApp_ReplyType = .replyNone
    var _errors: [FkApp_Error] = []
    var _status: FkApp_Status? = nil
    var _networkSettings: FkApp_NetworkSettings? = nil
    var _loraSettings: FkApp_LoraSettings? = nil
    var _modules: [FkApp_ModuleCapabilities] = []
    var _streams: [FkApp_DataStream] = []
    var _liveReadings: [FkApp_LiveReadings] = []
    var _schedules: FkApp_Schedules? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _errors = source._errors
      _status = source._status
      _networkSettings = source._networkSettings
      _loraSettings = source._loraSettings
      _modules = source._modules
      _streams = source._streams
      _liveReadings = source._liveReadings
      _schedules = source._schedules
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._errors)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._status)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._networkSettings)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._modules)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._streams)
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._liveReadings)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._loraSettings)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._schedules)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type != .replyNone {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if !_storage._errors.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._errors, fieldNumber: 2)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._networkSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._modules.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._modules, fieldNumber: 5)
      }
      if !_storage._streams.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._streams, fieldNumber: 6)
      }
      if !_storage._liveReadings.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._liveReadings, fieldNumber: 7)
      }
      if let v = _storage._loraSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._schedules {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FkApp_HttpReply, rhs: FkApp_HttpReply) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._errors != rhs_storage._errors {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._networkSettings != rhs_storage._networkSettings {return false}
        if _storage._loraSettings != rhs_storage._loraSettings {return false}
        if _storage._modules != rhs_storage._modules {return false}
        if _storage._streams != rhs_storage._streams {return false}
        if _storage._liveReadings != rhs_storage._liveReadings {return false}
        if _storage._schedules != rhs_storage._schedules {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
